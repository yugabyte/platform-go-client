/*
YugabyteDB Anywhere APIs

ALPHA - NOT FOR EXTERNAL USE

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DisasterRecoveryAPIService DisasterRecoveryAPI service
type DisasterRecoveryAPIService service

type DisasterRecoveryAPICreateDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	disasterRecoveryCreateFormData *DrConfigCreateForm
	request *interface{}
}

// Disaster Recovery Create Form Data
func (r DisasterRecoveryAPICreateDrConfigRequest) DisasterRecoveryCreateFormData(disasterRecoveryCreateFormData DrConfigCreateForm) DisasterRecoveryAPICreateDrConfigRequest {
	r.disasterRecoveryCreateFormData = &disasterRecoveryCreateFormData
	return r
}

func (r DisasterRecoveryAPICreateDrConfigRequest) Request(request interface{}) DisasterRecoveryAPICreateDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPICreateDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.CreateDrConfigExecute(r)
}

/*
CreateDrConfig Create disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @return DisasterRecoveryAPICreateDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) CreateDrConfig(ctx context.Context, cUUID string) DisasterRecoveryAPICreateDrConfigRequest {
	return DisasterRecoveryAPICreateDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) CreateDrConfigExecute(r DisasterRecoveryAPICreateDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.CreateDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoveryCreateFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoveryCreateFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoveryCreateFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIDeleteXClusterConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	isForceDelete *bool
	request *interface{}
}

func (r DisasterRecoveryAPIDeleteXClusterConfigRequest) IsForceDelete(isForceDelete bool) DisasterRecoveryAPIDeleteXClusterConfigRequest {
	r.isForceDelete = &isForceDelete
	return r
}

func (r DisasterRecoveryAPIDeleteXClusterConfigRequest) Request(request interface{}) DisasterRecoveryAPIDeleteXClusterConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIDeleteXClusterConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.DeleteXClusterConfigExecute(r)
}

/*
DeleteXClusterConfig Delete xcluster config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIDeleteXClusterConfigRequest
*/
func (a *DisasterRecoveryAPIService) DeleteXClusterConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIDeleteXClusterConfigRequest {
	return DisasterRecoveryAPIDeleteXClusterConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) DeleteXClusterConfigExecute(r DisasterRecoveryAPIDeleteXClusterConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.DeleteXClusterConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isForceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", r.isForceDelete, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", defaultValue, "", "")
		r.isForceDelete = &defaultValue
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIEditDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoveryEditFormData *DrConfigEditForm
	request *interface{}
}

// Disaster Recovery Edit Form Data
func (r DisasterRecoveryAPIEditDrConfigRequest) DisasterRecoveryEditFormData(disasterRecoveryEditFormData DrConfigEditForm) DisasterRecoveryAPIEditDrConfigRequest {
	r.disasterRecoveryEditFormData = &disasterRecoveryEditFormData
	return r
}

func (r DisasterRecoveryAPIEditDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIEditDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIEditDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.EditDrConfigExecute(r)
}

/*
EditDrConfig Edit disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIEditDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) EditDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIEditDrConfigRequest {
	return DisasterRecoveryAPIEditDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) EditDrConfigExecute(r DisasterRecoveryAPIEditDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.EditDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/edit"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoveryEditFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoveryEditFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoveryEditFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIFailoverDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoveryFailoverFormData *DrConfigFailoverForm
	request *interface{}
}

// Disaster Recovery Failover Form Data
func (r DisasterRecoveryAPIFailoverDrConfigRequest) DisasterRecoveryFailoverFormData(disasterRecoveryFailoverFormData DrConfigFailoverForm) DisasterRecoveryAPIFailoverDrConfigRequest {
	r.disasterRecoveryFailoverFormData = &disasterRecoveryFailoverFormData
	return r
}

func (r DisasterRecoveryAPIFailoverDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIFailoverDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIFailoverDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.FailoverDrConfigExecute(r)
}

/*
FailoverDrConfig Failover a disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIFailoverDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) FailoverDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIFailoverDrConfigRequest {
	return DisasterRecoveryAPIFailoverDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) FailoverDrConfigExecute(r DisasterRecoveryAPIFailoverDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.FailoverDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/failover"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoveryFailoverFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoveryFailoverFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoveryFailoverFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIGetDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	syncWithDB *bool
}

func (r DisasterRecoveryAPIGetDrConfigRequest) SyncWithDB(syncWithDB bool) DisasterRecoveryAPIGetDrConfigRequest {
	r.syncWithDB = &syncWithDB
	return r
}

func (r DisasterRecoveryAPIGetDrConfigRequest) Execute() (*DrConfigGetResp, *http.Response, error) {
	return r.ApiService.GetDrConfigExecute(r)
}

/*
GetDrConfig Get disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIGetDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) GetDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIGetDrConfigRequest {
	return DisasterRecoveryAPIGetDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return DrConfigGetResp
func (a *DisasterRecoveryAPIService) GetDrConfigExecute(r DisasterRecoveryAPIGetDrConfigRequest) (*DrConfigGetResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DrConfigGetResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.GetDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.syncWithDB != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "syncWithDB", r.syncWithDB, "", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "syncWithDB", defaultValue, "", "")
		r.syncWithDB = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIGetDrConfigSafetimeRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
}

func (r DisasterRecoveryAPIGetDrConfigSafetimeRequest) Execute() (*DrConfigSafetimeResp, *http.Response, error) {
	return r.ApiService.GetDrConfigSafetimeExecute(r)
}

/*
GetDrConfigSafetime Get disaster recovery config safetime

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIGetDrConfigSafetimeRequest
*/
func (a *DisasterRecoveryAPIService) GetDrConfigSafetime(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIGetDrConfigSafetimeRequest {
	return DisasterRecoveryAPIGetDrConfigSafetimeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return DrConfigSafetimeResp
func (a *DisasterRecoveryAPIService) GetDrConfigSafetimeExecute(r DisasterRecoveryAPIGetDrConfigSafetimeRequest) (*DrConfigSafetimeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DrConfigSafetimeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.GetDrConfigSafetime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/safetime"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIPauseDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	request *interface{}
}

func (r DisasterRecoveryAPIPauseDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIPauseDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIPauseDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.PauseDrConfigExecute(r)
}

/*
PauseDrConfig Pause DR config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIPauseDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) PauseDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIPauseDrConfigRequest {
	return DisasterRecoveryAPIPauseDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) PauseDrConfigExecute(r DisasterRecoveryAPIPauseDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.PauseDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIPauseDrUniversesRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	request *interface{}
}

func (r DisasterRecoveryAPIPauseDrUniversesRequest) Request(request interface{}) DisasterRecoveryAPIPauseDrUniversesRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIPauseDrUniversesRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.PauseDrUniversesExecute(r)
}

/*
PauseDrUniverses Pause DR config and universes associated with DR

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIPauseDrUniversesRequest
*/
func (a *DisasterRecoveryAPIService) PauseDrUniverses(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIPauseDrUniversesRequest {
	return DisasterRecoveryAPIPauseDrUniversesRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) PauseDrUniversesExecute(r DisasterRecoveryAPIPauseDrUniversesRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.PauseDrUniverses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/pause_universes"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIReplaceReplicaDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoveryReplaceReplicaFormData *DrConfigReplaceReplicaForm
	request *interface{}
}

// Disaster Recovery Replace Replica Form Data
func (r DisasterRecoveryAPIReplaceReplicaDrConfigRequest) DisasterRecoveryReplaceReplicaFormData(disasterRecoveryReplaceReplicaFormData DrConfigReplaceReplicaForm) DisasterRecoveryAPIReplaceReplicaDrConfigRequest {
	r.disasterRecoveryReplaceReplicaFormData = &disasterRecoveryReplaceReplicaFormData
	return r
}

func (r DisasterRecoveryAPIReplaceReplicaDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIReplaceReplicaDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIReplaceReplicaDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.ReplaceReplicaDrConfigExecute(r)
}

/*
ReplaceReplicaDrConfig Replace Replica in a disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIReplaceReplicaDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) ReplaceReplicaDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIReplaceReplicaDrConfigRequest {
	return DisasterRecoveryAPIReplaceReplicaDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) ReplaceReplicaDrConfigExecute(r DisasterRecoveryAPIReplaceReplicaDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.ReplaceReplicaDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/replace_replica"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoveryReplaceReplicaFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoveryReplaceReplicaFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoveryReplaceReplicaFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIRestartDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoveryRestartFormData *DrConfigRestartForm
	isForceDelete *bool
	request *interface{}
}

// Disaster Recovery Restart Form Data
func (r DisasterRecoveryAPIRestartDrConfigRequest) DisasterRecoveryRestartFormData(disasterRecoveryRestartFormData DrConfigRestartForm) DisasterRecoveryAPIRestartDrConfigRequest {
	r.disasterRecoveryRestartFormData = &disasterRecoveryRestartFormData
	return r
}

func (r DisasterRecoveryAPIRestartDrConfigRequest) IsForceDelete(isForceDelete bool) DisasterRecoveryAPIRestartDrConfigRequest {
	r.isForceDelete = &isForceDelete
	return r
}

func (r DisasterRecoveryAPIRestartDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIRestartDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIRestartDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.RestartDrConfigExecute(r)
}

/*
RestartDrConfig Restart disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIRestartDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) RestartDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIRestartDrConfigRequest {
	return DisasterRecoveryAPIRestartDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) RestartDrConfigExecute(r DisasterRecoveryAPIRestartDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.RestartDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoveryRestartFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoveryRestartFormData is required and must be specified")
	}

	if r.isForceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", r.isForceDelete, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", defaultValue, "", "")
		r.isForceDelete = &defaultValue
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoveryRestartFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIResumeDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	request *interface{}
}

func (r DisasterRecoveryAPIResumeDrConfigRequest) Request(request interface{}) DisasterRecoveryAPIResumeDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIResumeDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.ResumeDrConfigExecute(r)
}

/*
ResumeDrConfig Resume DR config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIResumeDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) ResumeDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIResumeDrConfigRequest {
	return DisasterRecoveryAPIResumeDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) ResumeDrConfigExecute(r DisasterRecoveryAPIResumeDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.ResumeDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPIResumeDrUniversesRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	request *interface{}
}

func (r DisasterRecoveryAPIResumeDrUniversesRequest) Request(request interface{}) DisasterRecoveryAPIResumeDrUniversesRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPIResumeDrUniversesRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.ResumeDrUniversesExecute(r)
}

/*
ResumeDrUniverses Resume DR config and universes associated with DR

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPIResumeDrUniversesRequest
*/
func (a *DisasterRecoveryAPIService) ResumeDrUniverses(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPIResumeDrUniversesRequest {
	return DisasterRecoveryAPIResumeDrUniversesRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) ResumeDrUniversesExecute(r DisasterRecoveryAPIResumeDrUniversesRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.ResumeDrUniverses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/resume_universes"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPISetDatabasesDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoverySetDatabasesFormData *DrConfigSetDatabasesForm
	request *interface{}
}

// Disaster Recovery Set Databases Form Data
func (r DisasterRecoveryAPISetDatabasesDrConfigRequest) DisasterRecoverySetDatabasesFormData(disasterRecoverySetDatabasesFormData DrConfigSetDatabasesForm) DisasterRecoveryAPISetDatabasesDrConfigRequest {
	r.disasterRecoverySetDatabasesFormData = &disasterRecoverySetDatabasesFormData
	return r
}

func (r DisasterRecoveryAPISetDatabasesDrConfigRequest) Request(request interface{}) DisasterRecoveryAPISetDatabasesDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPISetDatabasesDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.SetDatabasesDrConfigExecute(r)
}

/*
SetDatabasesDrConfig Set databases in disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPISetDatabasesDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) SetDatabasesDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPISetDatabasesDrConfigRequest {
	return DisasterRecoveryAPISetDatabasesDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) SetDatabasesDrConfigExecute(r DisasterRecoveryAPISetDatabasesDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.SetDatabasesDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/set_dbs"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoverySetDatabasesFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoverySetDatabasesFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoverySetDatabasesFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPISetTablesDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoverySetTablesFormData *DrConfigSetTablesForm
	request *interface{}
}

// Disaster Recovery Set Tables Form Data
func (r DisasterRecoveryAPISetTablesDrConfigRequest) DisasterRecoverySetTablesFormData(disasterRecoverySetTablesFormData DrConfigSetTablesForm) DisasterRecoveryAPISetTablesDrConfigRequest {
	r.disasterRecoverySetTablesFormData = &disasterRecoverySetTablesFormData
	return r
}

func (r DisasterRecoveryAPISetTablesDrConfigRequest) Request(request interface{}) DisasterRecoveryAPISetTablesDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPISetTablesDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.SetTablesDrConfigExecute(r)
}

/*
SetTablesDrConfig Set tables in disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPISetTablesDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) SetTablesDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPISetTablesDrConfigRequest {
	return DisasterRecoveryAPISetTablesDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) SetTablesDrConfigExecute(r DisasterRecoveryAPISetTablesDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.SetTablesDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/set_tables"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoverySetTablesFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoverySetTablesFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoverySetTablesFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPISwitchoverDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	disasterRecoverySwitchoverFormData *DrConfigSwitchoverForm
	request *interface{}
}

// Disaster Recovery Switchover Form Data
func (r DisasterRecoveryAPISwitchoverDrConfigRequest) DisasterRecoverySwitchoverFormData(disasterRecoverySwitchoverFormData DrConfigSwitchoverForm) DisasterRecoveryAPISwitchoverDrConfigRequest {
	r.disasterRecoverySwitchoverFormData = &disasterRecoverySwitchoverFormData
	return r
}

func (r DisasterRecoveryAPISwitchoverDrConfigRequest) Request(request interface{}) DisasterRecoveryAPISwitchoverDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPISwitchoverDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.SwitchoverDrConfigExecute(r)
}

/*
SwitchoverDrConfig Switchover a disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPISwitchoverDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) SwitchoverDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPISwitchoverDrConfigRequest {
	return DisasterRecoveryAPISwitchoverDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) SwitchoverDrConfigExecute(r DisasterRecoveryAPISwitchoverDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.SwitchoverDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/switchover"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disasterRecoverySwitchoverFormData == nil {
		return localVarReturnValue, nil, reportError("disasterRecoverySwitchoverFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disasterRecoverySwitchoverFormData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DisasterRecoveryAPISyncDrConfigRequest struct {
	ctx context.Context
	ApiService *DisasterRecoveryAPIService
	cUUID string
	drUUID string
	request *interface{}
}

func (r DisasterRecoveryAPISyncDrConfigRequest) Request(request interface{}) DisasterRecoveryAPISyncDrConfigRequest {
	r.request = &request
	return r
}

func (r DisasterRecoveryAPISyncDrConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.SyncDrConfigExecute(r)
}

/*
SyncDrConfig Sync disaster recovery config

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param drUUID
 @return DisasterRecoveryAPISyncDrConfigRequest
*/
func (a *DisasterRecoveryAPIService) SyncDrConfig(ctx context.Context, cUUID string, drUUID string) DisasterRecoveryAPISyncDrConfigRequest {
	return DisasterRecoveryAPISyncDrConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		drUUID: drUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *DisasterRecoveryAPIService) SyncDrConfigExecute(r DisasterRecoveryAPISyncDrConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisasterRecoveryAPIService.SyncDrConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/dr_configs/{drUUID}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drUUID"+"}", url.PathEscape(parameterValueToString(r.drUUID, "drUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
