/*
YugabyteDB Anywhere APIs

ALPHA - NOT FOR EXTERNAL USE

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SessionManagementAPIService SessionManagementAPI service
type SessionManagementAPIService service

type SessionManagementAPIApiLoginRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	customerLoginFormData *CustomerLoginFormData
	request *interface{}
}

func (r SessionManagementAPIApiLoginRequest) CustomerLoginFormData(customerLoginFormData CustomerLoginFormData) SessionManagementAPIApiLoginRequest {
	r.customerLoginFormData = &customerLoginFormData
	return r
}

func (r SessionManagementAPIApiLoginRequest) Request(request interface{}) SessionManagementAPIApiLoginRequest {
	r.request = &request
	return r
}

func (r SessionManagementAPIApiLoginRequest) Execute() (*SessionInfo, *http.Response, error) {
	return r.ApiService.ApiLoginExecute(r)
}

/*
ApiLogin Authenticate user using email and password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPIApiLoginRequest
*/
func (a *SessionManagementAPIService) ApiLogin(ctx context.Context) SessionManagementAPIApiLoginRequest {
	return SessionManagementAPIApiLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SessionInfo
func (a *SessionManagementAPIService) ApiLoginExecute(r SessionManagementAPIApiLoginRequest) (*SessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.ApiLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/api_login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customerLoginFormData == nil {
		return localVarReturnValue, nil, reportError("customerLoginFormData is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customerLoginFormData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIApiTokenRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	cUUID string
	apiTokenVersion *int64
	request *interface{}
}

func (r SessionManagementAPIApiTokenRequest) ApiTokenVersion(apiTokenVersion int64) SessionManagementAPIApiTokenRequest {
	r.apiTokenVersion = &apiTokenVersion
	return r
}

func (r SessionManagementAPIApiTokenRequest) Request(request interface{}) SessionManagementAPIApiTokenRequest {
	r.request = &request
	return r
}

func (r SessionManagementAPIApiTokenRequest) Execute() (*SessionInfo, *http.Response, error) {
	return r.ApiService.ApiTokenExecute(r)
}

/*
ApiToken Regenerate and fetch API token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @return SessionManagementAPIApiTokenRequest
*/
func (a *SessionManagementAPIService) ApiToken(ctx context.Context, cUUID string) SessionManagementAPIApiTokenRequest {
	return SessionManagementAPIApiTokenRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return SessionInfo
func (a *SessionManagementAPIService) ApiTokenExecute(r SessionManagementAPIApiTokenRequest) (*SessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.ApiToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/api_token"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiTokenVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiTokenVersion", r.apiTokenVersion, "", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "apiTokenVersion", defaultValue, "", "")
        r.apiTokenVersion = &defaultValue
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIAppVersionRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
}

func (r SessionManagementAPIAppVersionRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.AppVersionExecute(r)
}

/*
AppVersion appVersion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPIAppVersionRequest
*/
func (a *SessionManagementAPIService) AppVersion(ctx context.Context) SessionManagementAPIAppVersionRequest {
	return SessionManagementAPIAppVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *SessionManagementAPIService) AppVersionExecute(r SessionManagementAPIAppVersionRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.AppVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/app_version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPICustomerCountRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
}

func (r SessionManagementAPICustomerCountRequest) Execute() (*CustomerCountResp, *http.Response, error) {
	return r.ApiService.CustomerCountExecute(r)
}

/*
CustomerCount customerCount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPICustomerCountRequest
*/
func (a *SessionManagementAPIService) CustomerCount(ctx context.Context) SessionManagementAPICustomerCountRequest {
	return SessionManagementAPICustomerCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCountResp
func (a *SessionManagementAPIService) CustomerCountExecute(r SessionManagementAPICustomerCountRequest) (*CustomerCountResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCountResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.CustomerCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customer_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIGetAdminNotificationsRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	cUUID string
}

func (r SessionManagementAPIGetAdminNotificationsRequest) Execute() (*CurrentAdminNotificationMessages, *http.Response, error) {
	return r.ApiService.GetAdminNotificationsExecute(r)
}

/*
GetAdminNotifications Current list of notifications for admin

WARNING: This is a preview API that could change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @return SessionManagementAPIGetAdminNotificationsRequest
*/
func (a *SessionManagementAPIService) GetAdminNotifications(ctx context.Context, cUUID string) SessionManagementAPIGetAdminNotificationsRequest {
	return SessionManagementAPIGetAdminNotificationsRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return CurrentAdminNotificationMessages
func (a *SessionManagementAPIService) GetAdminNotificationsExecute(r SessionManagementAPIGetAdminNotificationsRequest) (*CurrentAdminNotificationMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrentAdminNotificationMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.GetAdminNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/admin_notifications"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIGetFilteredLogsRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	maxLines *int32
	universeName *string
	queryRegex *string
	startDate *string
	endDate *string
}

func (r SessionManagementAPIGetFilteredLogsRequest) MaxLines(maxLines int32) SessionManagementAPIGetFilteredLogsRequest {
	r.maxLines = &maxLines
	return r
}

func (r SessionManagementAPIGetFilteredLogsRequest) UniverseName(universeName string) SessionManagementAPIGetFilteredLogsRequest {
	r.universeName = &universeName
	return r
}

func (r SessionManagementAPIGetFilteredLogsRequest) QueryRegex(queryRegex string) SessionManagementAPIGetFilteredLogsRequest {
	r.queryRegex = &queryRegex
	return r
}

func (r SessionManagementAPIGetFilteredLogsRequest) StartDate(startDate string) SessionManagementAPIGetFilteredLogsRequest {
	r.startDate = &startDate
	return r
}

func (r SessionManagementAPIGetFilteredLogsRequest) EndDate(endDate string) SessionManagementAPIGetFilteredLogsRequest {
	r.endDate = &endDate
	return r
}

func (r SessionManagementAPIGetFilteredLogsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetFilteredLogsExecute(r)
}

/*
GetFilteredLogs getFilteredLogs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPIGetFilteredLogsRequest
*/
func (a *SessionManagementAPIService) GetFilteredLogs(ctx context.Context) SessionManagementAPIGetFilteredLogsRequest {
	return SessionManagementAPIGetFilteredLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SessionManagementAPIService) GetFilteredLogsExecute(r SessionManagementAPIGetFilteredLogsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.GetFilteredLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxLines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxLines", r.maxLines, "", "")
	} else {
        var defaultValue int32 = 10000
        parameterAddToHeaderOrQuery(localVarQueryParams, "maxLines", defaultValue, "", "")
        r.maxLines = &defaultValue
	}
	if r.universeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universeName", r.universeName, "", "")
	} else {
        var defaultValue string = "null"
        parameterAddToHeaderOrQuery(localVarQueryParams, "universeName", defaultValue, "", "")
        r.universeName = &defaultValue
	}
	if r.queryRegex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryRegex", r.queryRegex, "", "")
	} else {
        var defaultValue string = "null"
        parameterAddToHeaderOrQuery(localVarQueryParams, "queryRegex", defaultValue, "", "")
        r.queryRegex = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "", "")
	} else {
        var defaultValue string = "null"
        parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", defaultValue, "", "")
        r.startDate = &defaultValue
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "", "")
	} else {
        var defaultValue string = "null"
        parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", defaultValue, "", "")
        r.endDate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIGetLogsRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	maxLines int32
}

func (r SessionManagementAPIGetLogsRequest) Execute() (*LogData, *http.Response, error) {
	return r.ApiService.GetLogsExecute(r)
}

/*
GetLogs getLogs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maxLines
 @return SessionManagementAPIGetLogsRequest
*/
func (a *SessionManagementAPIService) GetLogs(ctx context.Context, maxLines int32) SessionManagementAPIGetLogsRequest {
	return SessionManagementAPIGetLogsRequest{
		ApiService: a,
		ctx: ctx,
		maxLines: maxLines,
	}
}

// Execute executes the request
//  @return LogData
func (a *SessionManagementAPIService) GetLogsExecute(r SessionManagementAPIGetLogsRequest) (*LogData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.GetLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/logs/{maxLines}"
	localVarPath = strings.Replace(localVarPath, "{"+"maxLines"+"}", url.PathEscape(parameterValueToString(r.maxLines, "maxLines")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIGetSessionInfoRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	request *interface{}
}

func (r SessionManagementAPIGetSessionInfoRequest) Request(request interface{}) SessionManagementAPIGetSessionInfoRequest {
	r.request = &request
	return r
}

func (r SessionManagementAPIGetSessionInfoRequest) Execute() (*SessionInfo, *http.Response, error) {
	return r.ApiService.GetSessionInfoExecute(r)
}

/*
GetSessionInfo Get current user and customer uuid. This will not generate or return the API token, use /api_token API for that.

Available since YBA version 2.20.0.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPIGetSessionInfoRequest
*/
func (a *SessionManagementAPIService) GetSessionInfo(ctx context.Context) SessionManagementAPIGetSessionInfoRequest {
	return SessionManagementAPIGetSessionInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SessionInfo
func (a *SessionManagementAPIService) GetSessionInfoExecute(r SessionManagementAPIGetSessionInfoRequest) (*SessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.GetSessionInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/session_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionManagementAPIRegisterCustomerRequest struct {
	ctx context.Context
	ApiService *SessionManagementAPIService
	customerRegisterFormData *CustomerRegisterFormData
	generateApiToken *bool
	request *interface{}
}

func (r SessionManagementAPIRegisterCustomerRequest) CustomerRegisterFormData(customerRegisterFormData CustomerRegisterFormData) SessionManagementAPIRegisterCustomerRequest {
	r.customerRegisterFormData = &customerRegisterFormData
	return r
}

func (r SessionManagementAPIRegisterCustomerRequest) GenerateApiToken(generateApiToken bool) SessionManagementAPIRegisterCustomerRequest {
	r.generateApiToken = &generateApiToken
	return r
}

func (r SessionManagementAPIRegisterCustomerRequest) Request(request interface{}) SessionManagementAPIRegisterCustomerRequest {
	r.request = &request
	return r
}

func (r SessionManagementAPIRegisterCustomerRequest) Execute() (*SessionInfo, *http.Response, error) {
	return r.ApiService.RegisterCustomerExecute(r)
}

/*
RegisterCustomer Register a customer

Creates new customer and user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionManagementAPIRegisterCustomerRequest
*/
func (a *SessionManagementAPIService) RegisterCustomer(ctx context.Context) SessionManagementAPIRegisterCustomerRequest {
	return SessionManagementAPIRegisterCustomerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SessionInfo
func (a *SessionManagementAPIService) RegisterCustomerExecute(r SessionManagementAPIRegisterCustomerRequest) (*SessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionManagementAPIService.RegisterCustomer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customerRegisterFormData == nil {
		return localVarReturnValue, nil, reportError("customerRegisterFormData is required and must be specified")
	}

	if r.generateApiToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateApiToken", r.generateApiToken, "", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "generateApiToken", defaultValue, "", "")
        r.generateApiToken = &defaultValue
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customerRegisterFormData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
