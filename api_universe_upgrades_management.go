/*
 * YugabyteDB Anywhere APIs
 *
 * ALPHA - NOT FOR EXTERNAL USE
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UniverseUpgradesManagementApiService UniverseUpgradesManagementApi service
type UniverseUpgradesManagementApiService service

type UniverseUpgradesManagementApiApiFinalizeUpgradeRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	finalizeUpgradeParams *FinalizeUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiFinalizeUpgradeRequest) FinalizeUpgradeParams(finalizeUpgradeParams FinalizeUpgradeParams) UniverseUpgradesManagementApiApiFinalizeUpgradeRequest {
	r.finalizeUpgradeParams = &finalizeUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiFinalizeUpgradeRequest) Request(request interface{}) UniverseUpgradesManagementApiApiFinalizeUpgradeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiFinalizeUpgradeRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.FinalizeUpgradeExecute(r)
}

/*
 * FinalizeUpgrade Finalize Upgrade
 * WARNING: This is a preview API that could change. Queues a task to finalize upgrade in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiFinalizeUpgradeRequest
 */
func (a *UniverseUpgradesManagementApiService) FinalizeUpgrade(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiFinalizeUpgradeRequest {
	return UniverseUpgradesManagementApiApiFinalizeUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) FinalizeUpgradeExecute(r UniverseUpgradesManagementApiApiFinalizeUpgradeRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.FinalizeUpgrade")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/finalize"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.finalizeUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("finalizeUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finalizeUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
}


func (r UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest) Execute() (FinalizeUpgradeInfoResponse, *_nethttp.Response, error) {
	return r.ApiService.PreFinalizeSoftwareUpgradeInfoExecute(r)
}

/*
 * PreFinalizeSoftwareUpgradeInfo Finalize Software Upgrade info
 * WARNING: This is a preview API that could change. Provides pre-finalize software upgrade info.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest
 */
func (a *UniverseUpgradesManagementApiService) PreFinalizeSoftwareUpgradeInfo(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest {
	return UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return FinalizeUpgradeInfoResponse
 */
func (a *UniverseUpgradesManagementApiService) PreFinalizeSoftwareUpgradeInfoExecute(r UniverseUpgradesManagementApiApiPreFinalizeSoftwareUpgradeInfoRequest) (FinalizeUpgradeInfoResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FinalizeUpgradeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.PreFinalizeSoftwareUpgradeInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/finalize/info"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiPreUpgradeValidationRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	upgradeParams *UpgradeTaskParams
	upgradeType *string
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiPreUpgradeValidationRequest) UpgradeParams(upgradeParams UpgradeTaskParams) UniverseUpgradesManagementApiApiPreUpgradeValidationRequest {
	r.upgradeParams = &upgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiPreUpgradeValidationRequest) UpgradeType(upgradeType string) UniverseUpgradesManagementApiApiPreUpgradeValidationRequest {
	r.upgradeType = &upgradeType
	return r
}
func (r UniverseUpgradesManagementApiApiPreUpgradeValidationRequest) Request(request interface{}) UniverseUpgradesManagementApiApiPreUpgradeValidationRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiPreUpgradeValidationRequest) Execute() (PreUpgradeValidationResponse, *_nethttp.Response, error) {
	return r.ApiService.PreUpgradeValidationExecute(r)
}

/*
 * PreUpgradeValidation Run validation for upgrade
 * WARNING: This is a preview API that could change. Runs all the prechecks and validations for specific upgrade
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiPreUpgradeValidationRequest
 */
func (a *UniverseUpgradesManagementApiService) PreUpgradeValidation(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiPreUpgradeValidationRequest {
	return UniverseUpgradesManagementApiApiPreUpgradeValidationRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return PreUpgradeValidationResponse
 */
func (a *UniverseUpgradesManagementApiService) PreUpgradeValidationExecute(r UniverseUpgradesManagementApiApiPreUpgradeValidationRequest) (PreUpgradeValidationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PreUpgradeValidationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.PreUpgradeValidation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/pre_upgrade_validation"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.upgradeParams == nil {
		return localVarReturnValue, nil, reportError("upgradeParams is required and must be specified")
	}

	if r.upgradeType != nil {
		localVarQueryParams.Add("upgradeType", parameterToString(*r.upgradeType, ""))
	}
	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiRebootUniverseRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	upgradeTaskParams *UpgradeTaskParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiRebootUniverseRequest) UpgradeTaskParams(upgradeTaskParams UpgradeTaskParams) UniverseUpgradesManagementApiApiRebootUniverseRequest {
	r.upgradeTaskParams = &upgradeTaskParams
	return r
}
func (r UniverseUpgradesManagementApiApiRebootUniverseRequest) Request(request interface{}) UniverseUpgradesManagementApiApiRebootUniverseRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiRebootUniverseRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.RebootUniverseExecute(r)
}

/*
 * RebootUniverse Reboot universe
 * Queues a task to perform a rolling reboot in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiRebootUniverseRequest
 */
func (a *UniverseUpgradesManagementApiService) RebootUniverse(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiRebootUniverseRequest {
	return UniverseUpgradesManagementApiApiRebootUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) RebootUniverseExecute(r UniverseUpgradesManagementApiApiRebootUniverseRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.RebootUniverse")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.upgradeTaskParams == nil {
		return localVarReturnValue, nil, reportError("upgradeTaskParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiResizeNodeRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	resizeNodeParams *ResizeNodeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiResizeNodeRequest) ResizeNodeParams(resizeNodeParams ResizeNodeParams) UniverseUpgradesManagementApiApiResizeNodeRequest {
	r.resizeNodeParams = &resizeNodeParams
	return r
}
func (r UniverseUpgradesManagementApiApiResizeNodeRequest) Request(request interface{}) UniverseUpgradesManagementApiApiResizeNodeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiResizeNodeRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.ResizeNodeExecute(r)
}

/*
 * ResizeNode Resize Node
 * Queues a task to perform node resize and rolling restart in a universe.<p>This API can be used to change the deviceInfo.volumeSize, masterDeviceInfo.volumeSize,instanceType, masterInstanceType of all the nodes of a Universe simultaneously without moving data from old nodes to new nodes. Refer: https://docs.yugabyte.com/preview/yugabyte-platform/manage-deployments/edit-universe/#smart-resize
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiResizeNodeRequest
 */
func (a *UniverseUpgradesManagementApiService) ResizeNode(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiResizeNodeRequest {
	return UniverseUpgradesManagementApiApiResizeNodeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) ResizeNodeExecute(r UniverseUpgradesManagementApiApiResizeNodeRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.ResizeNode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/resize_node"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resizeNodeParams == nil {
		return localVarReturnValue, nil, reportError("resizeNodeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeNodeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiRestartUniverseRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	restartTaskParams *RestartTaskParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiRestartUniverseRequest) RestartTaskParams(restartTaskParams RestartTaskParams) UniverseUpgradesManagementApiApiRestartUniverseRequest {
	r.restartTaskParams = &restartTaskParams
	return r
}
func (r UniverseUpgradesManagementApiApiRestartUniverseRequest) Request(request interface{}) UniverseUpgradesManagementApiApiRestartUniverseRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiRestartUniverseRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.RestartUniverseExecute(r)
}

/*
 * RestartUniverse Restart Universe
 * Queues a task to perform a rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiRestartUniverseRequest
 */
func (a *UniverseUpgradesManagementApiService) RestartUniverse(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiRestartUniverseRequest {
	return UniverseUpgradesManagementApiApiRestartUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) RestartUniverseExecute(r UniverseUpgradesManagementApiApiRestartUniverseRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.RestartUniverse")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.restartTaskParams == nil {
		return localVarReturnValue, nil, reportError("restartTaskParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiRollbackUpgradeRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	rollbackUpgradeParams *RollbackUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiRollbackUpgradeRequest) RollbackUpgradeParams(rollbackUpgradeParams RollbackUpgradeParams) UniverseUpgradesManagementApiApiRollbackUpgradeRequest {
	r.rollbackUpgradeParams = &rollbackUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiRollbackUpgradeRequest) Request(request interface{}) UniverseUpgradesManagementApiApiRollbackUpgradeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiRollbackUpgradeRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.RollbackUpgradeExecute(r)
}

/*
 * RollbackUpgrade Rollback Upgrade
 * WARNING: This is a preview API that could change. Queues a task to rollback upgrade in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiRollbackUpgradeRequest
 */
func (a *UniverseUpgradesManagementApiService) RollbackUpgrade(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiRollbackUpgradeRequest {
	return UniverseUpgradesManagementApiApiRollbackUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) RollbackUpgradeExecute(r UniverseUpgradesManagementApiApiRollbackUpgradeRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.RollbackUpgrade")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.rollbackUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("rollbackUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	softwareUpgradeInfoRequest *SoftwareUpgradeInfoRequest
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest) SoftwareUpgradeInfoRequest(softwareUpgradeInfoRequest SoftwareUpgradeInfoRequest) UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest {
	r.softwareUpgradeInfoRequest = &softwareUpgradeInfoRequest
	return r
}
func (r UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest) Request(request interface{}) UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest) Execute() (SoftwareUpgradeInfoResponse, *_nethttp.Response, error) {
	return r.ApiService.SoftwareUpgradePreCheckExecute(r)
}

/*
 * SoftwareUpgradePreCheck Software Upgrade universe pre-check
 * WARNING: This is a preview API that could change. Performs pre-checks and provides pre-upgrade info.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest
 */
func (a *UniverseUpgradesManagementApiService) SoftwareUpgradePreCheck(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest {
	return UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return SoftwareUpgradeInfoResponse
 */
func (a *UniverseUpgradesManagementApiService) SoftwareUpgradePreCheckExecute(r UniverseUpgradesManagementApiApiSoftwareUpgradePreCheckRequest) (SoftwareUpgradeInfoResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwareUpgradeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.SoftwareUpgradePreCheck")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/software/precheck"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwareUpgradeInfoRequest == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeInfoRequest is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpdateProxyConfigRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	updateProxyConfigParams *ProxyConfigUpdateParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpdateProxyConfigRequest) UpdateProxyConfigParams(updateProxyConfigParams ProxyConfigUpdateParams) UniverseUpgradesManagementApiApiUpdateProxyConfigRequest {
	r.updateProxyConfigParams = &updateProxyConfigParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpdateProxyConfigRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpdateProxyConfigRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpdateProxyConfigRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpdateProxyConfigExecute(r)
}

/*
 * UpdateProxyConfig Update Proxy Config
 * WARNING: This is a preview API that could change. Queues a task to perform Proxy config update in the Universe details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpdateProxyConfigRequest
 */
func (a *UniverseUpgradesManagementApiService) UpdateProxyConfig(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpdateProxyConfigRequest {
	return UniverseUpgradesManagementApiApiUpdateProxyConfigRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpdateProxyConfigExecute(r UniverseUpgradesManagementApiApiUpdateProxyConfigRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpdateProxyConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/proxy_config"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.updateProxyConfigParams == nil {
		return localVarReturnValue, nil, reportError("updateProxyConfigParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateProxyConfigParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeCertsRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	certsRotateParams *CertsRotateParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeCertsRequest) CertsRotateParams(certsRotateParams CertsRotateParams) UniverseUpgradesManagementApiApiUpgradeCertsRequest {
	r.certsRotateParams = &certsRotateParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeCertsRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeCertsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeCertsRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeCertsExecute(r)
}

/*
 * UpgradeCerts Upgrade Certs
 * Queues a task to perform certificate rotation and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeCertsRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeCerts(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeCertsRequest {
	return UniverseUpgradesManagementApiApiUpgradeCertsRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeCertsExecute(r UniverseUpgradesManagementApiApiUpgradeCertsRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeCerts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/certs"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.certsRotateParams == nil {
		return localVarReturnValue, nil, reportError("certsRotateParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.certsRotateParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeDBVersionRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	softwareUpgradeParams *SoftwareUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeDBVersionRequest) SoftwareUpgradeParams(softwareUpgradeParams SoftwareUpgradeParams) UniverseUpgradesManagementApiApiUpgradeDBVersionRequest {
	r.softwareUpgradeParams = &softwareUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeDBVersionRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeDBVersionRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeDBVersionRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeDBVersionExecute(r)
}

/*
 * UpgradeDBVersion Upgrade DB version
 * WARNING: This is a preview API that could change. This is a two step DB software version upgrade, Upgrade DB version and then finalize software which would be same as of upgrade software but additionally support rollback before upgrade finalize. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeDBVersionRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeDBVersion(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeDBVersionRequest {
	return UniverseUpgradesManagementApiApiUpgradeDBVersionRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeDBVersionExecute(r UniverseUpgradesManagementApiApiUpgradeDBVersionRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeDBVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/db_version"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeGFlagsRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	gflagsUpgradeParams *GFlagsUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeGFlagsRequest) GflagsUpgradeParams(gflagsUpgradeParams GFlagsUpgradeParams) UniverseUpgradesManagementApiApiUpgradeGFlagsRequest {
	r.gflagsUpgradeParams = &gflagsUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeGFlagsRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeGFlagsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeGFlagsRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeGFlagsExecute(r)
}

/*
 * UpgradeGFlags Upgrade GFlags
 * Queues a task to perform gflags upgrade and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeGFlagsRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeGFlags(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeGFlagsRequest {
	return UniverseUpgradesManagementApiApiUpgradeGFlagsRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeGFlagsExecute(r UniverseUpgradesManagementApiApiUpgradeGFlagsRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeGFlags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/gflags"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.gflagsUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("gflagsUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gflagsUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	kubernetesOverridesUpgradeParams *KubernetesOverridesUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest) KubernetesOverridesUpgradeParams(kubernetesOverridesUpgradeParams KubernetesOverridesUpgradeParams) UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest {
	r.kubernetesOverridesUpgradeParams = &kubernetesOverridesUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeKubernetesOverridesExecute(r)
}

/*
 * UpgradeKubernetesOverrides Upgrade KubernetesOverrides
 * Queues a task to perform Kubernetesoverrides upgrade for a kubernetes universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeKubernetesOverrides(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest {
	return UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeKubernetesOverridesExecute(r UniverseUpgradesManagementApiApiUpgradeKubernetesOverridesRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeKubernetesOverrides")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/kubernetes_overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesOverridesUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("kubernetesOverridesUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kubernetesOverridesUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeSoftwareRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	softwareUpgradeParams *SoftwareUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeSoftwareRequest) SoftwareUpgradeParams(softwareUpgradeParams SoftwareUpgradeParams) UniverseUpgradesManagementApiApiUpgradeSoftwareRequest {
	r.softwareUpgradeParams = &softwareUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeSoftwareRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeSoftwareRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeSoftwareRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeSoftwareExecute(r)
}

/*
 * UpgradeSoftware Upgrade Software
 * Queues a task to perform software upgrade and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeSoftwareRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeSoftware(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeSoftwareRequest {
	return UniverseUpgradesManagementApiApiUpgradeSoftwareRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeSoftwareExecute(r UniverseUpgradesManagementApiApiUpgradeSoftwareRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeSoftware")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeSystemdRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	systemdUpgradeParams *SystemdUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeSystemdRequest) SystemdUpgradeParams(systemdUpgradeParams SystemdUpgradeParams) UniverseUpgradesManagementApiApiUpgradeSystemdRequest {
	r.systemdUpgradeParams = &systemdUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeSystemdRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeSystemdRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeSystemdRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeSystemdExecute(r)
}

/*
 * UpgradeSystemd Upgrade Systemd
 * Queues a task to perform systemd upgrade and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeSystemdRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeSystemd(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeSystemdRequest {
	return UniverseUpgradesManagementApiApiUpgradeSystemdRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeSystemdExecute(r UniverseUpgradesManagementApiApiUpgradeSystemdRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeSystemd")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/systemd"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.systemdUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("systemdUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.systemdUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	thirdpartySoftwareUpgradeParams *ThirdpartySoftwareUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest) ThirdpartySoftwareUpgradeParams(thirdpartySoftwareUpgradeParams ThirdpartySoftwareUpgradeParams) UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest {
	r.thirdpartySoftwareUpgradeParams = &thirdpartySoftwareUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeThirdpartySoftwareExecute(r)
}

/*
 * UpgradeThirdpartySoftware Upgrade third-party software
 * Queues a task to perform upgrade third-party software in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeThirdpartySoftware(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest {
	return UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeThirdpartySoftwareExecute(r UniverseUpgradesManagementApiApiUpgradeThirdpartySoftwareRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeThirdpartySoftware")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/thirdparty_software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.thirdpartySoftwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("thirdpartySoftwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.thirdpartySoftwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeTlsRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	tlsToggleParams *TlsToggleParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeTlsRequest) TlsToggleParams(tlsToggleParams TlsToggleParams) UniverseUpgradesManagementApiApiUpgradeTlsRequest {
	r.tlsToggleParams = &tlsToggleParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeTlsRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeTlsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeTlsRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeTlsExecute(r)
}

/*
 * UpgradeTls Upgrade TLS
 * Queues a task to perform TLS ugprade and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeTlsRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeTls(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeTlsRequest {
	return UniverseUpgradesManagementApiApiUpgradeTlsRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeTlsExecute(r UniverseUpgradesManagementApiApiUpgradeTlsRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeTls")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/tls"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tlsToggleParams == nil {
		return localVarReturnValue, nil, reportError("tlsToggleParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsToggleParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementApiApiUpgradeVMImageRequest struct {
	ctx _context.Context
	ApiService *UniverseUpgradesManagementApiService
	cUUID string
	uniUUID string
	vmimageUpgradeParams *VMImageUpgradeParams
	request *interface{}
}

func (r UniverseUpgradesManagementApiApiUpgradeVMImageRequest) VmimageUpgradeParams(vmimageUpgradeParams VMImageUpgradeParams) UniverseUpgradesManagementApiApiUpgradeVMImageRequest {
	r.vmimageUpgradeParams = &vmimageUpgradeParams
	return r
}
func (r UniverseUpgradesManagementApiApiUpgradeVMImageRequest) Request(request interface{}) UniverseUpgradesManagementApiApiUpgradeVMImageRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementApiApiUpgradeVMImageRequest) Execute() (YBPTask, *_nethttp.Response, error) {
	return r.ApiService.UpgradeVMImageExecute(r)
}

/*
 * UpgradeVMImage Upgrade VM Image
 * Queues a task to perform VM Image upgrade and rolling restart in a universe.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cUUID
 * @param uniUUID
 * @return UniverseUpgradesManagementApiApiUpgradeVMImageRequest
 */
func (a *UniverseUpgradesManagementApiService) UpgradeVMImage(ctx _context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementApiApiUpgradeVMImageRequest {
	return UniverseUpgradesManagementApiApiUpgradeVMImageRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

/*
 * Execute executes the request
 * @return YBPTask
 */
func (a *UniverseUpgradesManagementApiService) UpgradeVMImageExecute(r UniverseUpgradesManagementApiApiUpgradeVMImageRequest) (YBPTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementApiService.UpgradeVMImage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/vm"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", _neturl.PathEscape(parameterToString(r.cUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", _neturl.PathEscape(parameterToString(r.uniUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vmimageUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("vmimageUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		localVarQueryParams.Add("request", parameterToString(*r.request, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vmimageUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
