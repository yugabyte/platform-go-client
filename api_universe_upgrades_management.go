/*
YugabyteDB Anywhere APIs

ALPHA - NOT FOR EXTERNAL USE

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// UniverseUpgradesManagementAPIService UniverseUpgradesManagementAPI service
type UniverseUpgradesManagementAPIService service

type UniverseUpgradesManagementAPIFinalizeUpgradeRequest struct {
	ctx                   context.Context
	ApiService            *UniverseUpgradesManagementAPIService
	cUUID                 string
	uniUUID               string
	finalizeUpgradeParams *FinalizeUpgradeParams
	request               *interface{}
}

// Finalize Upgrade Params
func (r UniverseUpgradesManagementAPIFinalizeUpgradeRequest) FinalizeUpgradeParams(finalizeUpgradeParams FinalizeUpgradeParams) UniverseUpgradesManagementAPIFinalizeUpgradeRequest {
	r.finalizeUpgradeParams = &finalizeUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIFinalizeUpgradeRequest) Request(request interface{}) UniverseUpgradesManagementAPIFinalizeUpgradeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIFinalizeUpgradeRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.FinalizeUpgradeExecute(r)
}

/*
FinalizeUpgrade Finalize Upgrade

WARNING: This is a preview API that could change. Queues a task to finalize upgrade in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIFinalizeUpgradeRequest
*/
func (a *UniverseUpgradesManagementAPIService) FinalizeUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIFinalizeUpgradeRequest {
	return UniverseUpgradesManagementAPIFinalizeUpgradeRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) FinalizeUpgradeExecute(r UniverseUpgradesManagementAPIFinalizeUpgradeRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.FinalizeUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/finalize"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finalizeUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("finalizeUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finalizeUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest struct {
	ctx                          context.Context
	ApiService                   *UniverseUpgradesManagementAPIService
	cUUID                        string
	uniUUID                      string
	kubernetesToggleImmutableYbc *KubernetesToggleImmutableYbcParams
	request                      *interface{}
}

// Kubernetes Toggle Immutable Ybc Params
func (r UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest) KubernetesToggleImmutableYbc(kubernetesToggleImmutableYbc KubernetesToggleImmutableYbcParams) UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest {
	r.kubernetesToggleImmutableYbc = &kubernetesToggleImmutableYbc
	return r
}

func (r UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest) Request(request interface{}) UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.KubernetesToggleImmutableYbcExecute(r)
}

/*
KubernetesToggleImmutableYbc Upgrade Kubernetes universe to toggle immutable YBC

WARNING: This is a preview API that could change. Queues a task to toggle immutable YBC on Kubernetes universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest
*/
func (a *UniverseUpgradesManagementAPIService) KubernetesToggleImmutableYbc(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest {
	return UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) KubernetesToggleImmutableYbcExecute(r UniverseUpgradesManagementAPIKubernetesToggleImmutableYbcRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.KubernetesToggleImmutableYbc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/k8s_immutable_ybc"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kubernetesToggleImmutableYbc == nil {
		return localVarReturnValue, nil, reportError("kubernetesToggleImmutableYbc is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kubernetesToggleImmutableYbc
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIModifyAuditLoggingRequest struct {
	ctx                context.Context
	ApiService         *UniverseUpgradesManagementAPIService
	cUUID              string
	uniUUID            string
	auditLoggingConfig *AuditLogConfigParams
	request            *interface{}
}

// Audit Logging Configuration
func (r UniverseUpgradesManagementAPIModifyAuditLoggingRequest) AuditLoggingConfig(auditLoggingConfig AuditLogConfigParams) UniverseUpgradesManagementAPIModifyAuditLoggingRequest {
	r.auditLoggingConfig = &auditLoggingConfig
	return r
}

func (r UniverseUpgradesManagementAPIModifyAuditLoggingRequest) Request(request interface{}) UniverseUpgradesManagementAPIModifyAuditLoggingRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIModifyAuditLoggingRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.ModifyAuditLoggingExecute(r)
}

/*
ModifyAuditLogging Modify Audit Logging Configuration

WARNING: This is a preview API that could change. Modifies the audit logging configuration for a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIModifyAuditLoggingRequest
*/
func (a *UniverseUpgradesManagementAPIService) ModifyAuditLogging(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIModifyAuditLoggingRequest {
	return UniverseUpgradesManagementAPIModifyAuditLoggingRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) ModifyAuditLoggingExecute(r UniverseUpgradesManagementAPIModifyAuditLoggingRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.ModifyAuditLogging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/audit_log_config"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auditLoggingConfig == nil {
		return localVarReturnValue, nil, reportError("auditLoggingConfig is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.auditLoggingConfig
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest struct {
	ctx        context.Context
	ApiService *UniverseUpgradesManagementAPIService
	cUUID      string
	uniUUID    string
}

func (r UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest) Execute() (*FinalizeUpgradeInfoResponse, *http.Response, error) {
	return r.ApiService.PreFinalizeSoftwareUpgradeInfoExecute(r)
}

/*
PreFinalizeSoftwareUpgradeInfo Finalize Software Upgrade info

WARNING: This is a preview API that could change. Provides pre-finalize software upgrade info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest
*/
func (a *UniverseUpgradesManagementAPIService) PreFinalizeSoftwareUpgradeInfo(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest {
	return UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return FinalizeUpgradeInfoResponse
func (a *UniverseUpgradesManagementAPIService) PreFinalizeSoftwareUpgradeInfoExecute(r UniverseUpgradesManagementAPIPreFinalizeSoftwareUpgradeInfoRequest) (*FinalizeUpgradeInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FinalizeUpgradeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.PreFinalizeSoftwareUpgradeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/finalize/info"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIRebootUniverseRequest struct {
	ctx               context.Context
	ApiService        *UniverseUpgradesManagementAPIService
	cUUID             string
	uniUUID           string
	upgradeTaskParams *UpgradeTaskParams
	request           *interface{}
}

// Upgrade Task Params
func (r UniverseUpgradesManagementAPIRebootUniverseRequest) UpgradeTaskParams(upgradeTaskParams UpgradeTaskParams) UniverseUpgradesManagementAPIRebootUniverseRequest {
	r.upgradeTaskParams = &upgradeTaskParams
	return r
}

func (r UniverseUpgradesManagementAPIRebootUniverseRequest) Request(request interface{}) UniverseUpgradesManagementAPIRebootUniverseRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIRebootUniverseRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.RebootUniverseExecute(r)
}

/*
RebootUniverse Reboot universe

Queues a task to perform a rolling reboot in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIRebootUniverseRequest
*/
func (a *UniverseUpgradesManagementAPIService) RebootUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIRebootUniverseRequest {
	return UniverseUpgradesManagementAPIRebootUniverseRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) RebootUniverseExecute(r UniverseUpgradesManagementAPIRebootUniverseRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.RebootUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upgradeTaskParams == nil {
		return localVarReturnValue, nil, reportError("upgradeTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIResizeNodeRequest struct {
	ctx              context.Context
	ApiService       *UniverseUpgradesManagementAPIService
	cUUID            string
	uniUUID          string
	resizeNodeParams *ResizeNodeParams
	request          *interface{}
}

// Resize Node Params
func (r UniverseUpgradesManagementAPIResizeNodeRequest) ResizeNodeParams(resizeNodeParams ResizeNodeParams) UniverseUpgradesManagementAPIResizeNodeRequest {
	r.resizeNodeParams = &resizeNodeParams
	return r
}

func (r UniverseUpgradesManagementAPIResizeNodeRequest) Request(request interface{}) UniverseUpgradesManagementAPIResizeNodeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIResizeNodeRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.ResizeNodeExecute(r)
}

/*
ResizeNode Resize Node

Queues a task to perform node resize and rolling restart in a universe.<p>This API can be used to change the deviceInfo.volumeSize, masterDeviceInfo.volumeSize,instanceType, masterInstanceType of all the nodes of a Universe simultaneously without moving data from old nodes to new nodes. Refer: https://docs.yugabyte.com/preview/yugabyte-platform/manage-deployments/edit-universe/#smart-resize

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIResizeNodeRequest
*/
func (a *UniverseUpgradesManagementAPIService) ResizeNode(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIResizeNodeRequest {
	return UniverseUpgradesManagementAPIResizeNodeRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) ResizeNodeExecute(r UniverseUpgradesManagementAPIResizeNodeRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.ResizeNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/resize_node"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resizeNodeParams == nil {
		return localVarReturnValue, nil, reportError("resizeNodeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeNodeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIRestartUniverseRequest struct {
	ctx               context.Context
	ApiService        *UniverseUpgradesManagementAPIService
	cUUID             string
	uniUUID           string
	restartTaskParams *RestartTaskParams
	request           *interface{}
}

// Restart Task Params
func (r UniverseUpgradesManagementAPIRestartUniverseRequest) RestartTaskParams(restartTaskParams RestartTaskParams) UniverseUpgradesManagementAPIRestartUniverseRequest {
	r.restartTaskParams = &restartTaskParams
	return r
}

func (r UniverseUpgradesManagementAPIRestartUniverseRequest) Request(request interface{}) UniverseUpgradesManagementAPIRestartUniverseRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIRestartUniverseRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.RestartUniverseExecute(r)
}

/*
RestartUniverse Restart Universe

Queues a task to perform a rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIRestartUniverseRequest
*/
func (a *UniverseUpgradesManagementAPIService) RestartUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIRestartUniverseRequest {
	return UniverseUpgradesManagementAPIRestartUniverseRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) RestartUniverseExecute(r UniverseUpgradesManagementAPIRestartUniverseRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.RestartUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restartTaskParams == nil {
		return localVarReturnValue, nil, reportError("restartTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIRollbackUpgradeRequest struct {
	ctx                   context.Context
	ApiService            *UniverseUpgradesManagementAPIService
	cUUID                 string
	uniUUID               string
	rollbackUpgradeParams *RollbackUpgradeParams
	request               *interface{}
}

// RollBack Upgrade Params
func (r UniverseUpgradesManagementAPIRollbackUpgradeRequest) RollbackUpgradeParams(rollbackUpgradeParams RollbackUpgradeParams) UniverseUpgradesManagementAPIRollbackUpgradeRequest {
	r.rollbackUpgradeParams = &rollbackUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIRollbackUpgradeRequest) Request(request interface{}) UniverseUpgradesManagementAPIRollbackUpgradeRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIRollbackUpgradeRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.RollbackUpgradeExecute(r)
}

/*
RollbackUpgrade Rollback Upgrade

WARNING: This is a preview API that could change. Queues a task to rollback upgrade in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIRollbackUpgradeRequest
*/
func (a *UniverseUpgradesManagementAPIService) RollbackUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIRollbackUpgradeRequest {
	return UniverseUpgradesManagementAPIRollbackUpgradeRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) RollbackUpgradeExecute(r UniverseUpgradesManagementAPIRollbackUpgradeRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.RollbackUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rollbackUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("rollbackUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest struct {
	ctx                        context.Context
	ApiService                 *UniverseUpgradesManagementAPIService
	cUUID                      string
	uniUUID                    string
	softwareUpgradeInfoRequest *SoftwareUpgradeInfoRequest
	request                    *interface{}
}

// Software Upgrade Info Request
func (r UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest) SoftwareUpgradeInfoRequest(softwareUpgradeInfoRequest SoftwareUpgradeInfoRequest) UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest {
	r.softwareUpgradeInfoRequest = &softwareUpgradeInfoRequest
	return r
}

func (r UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest) Request(request interface{}) UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest) Execute() (*SoftwareUpgradeInfoResponse, *http.Response, error) {
	return r.ApiService.SoftwareUpgradePreCheckExecute(r)
}

/*
SoftwareUpgradePreCheck Software Upgrade universe pre-check

WARNING: This is a preview API that could change. Performs pre-checks and provides pre-upgrade info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest
*/
func (a *UniverseUpgradesManagementAPIService) SoftwareUpgradePreCheck(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest {
	return UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return SoftwareUpgradeInfoResponse
func (a *UniverseUpgradesManagementAPIService) SoftwareUpgradePreCheckExecute(r UniverseUpgradesManagementAPISoftwareUpgradePreCheckRequest) (*SoftwareUpgradeInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoftwareUpgradeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.SoftwareUpgradePreCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/software/precheck"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareUpgradeInfoRequest == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeInfoRequest is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpdateProxyConfigRequest struct {
	ctx                     context.Context
	ApiService              *UniverseUpgradesManagementAPIService
	cUUID                   string
	uniUUID                 string
	updateProxyConfigParams *ProxyConfigUpdateParams
	request                 *interface{}
}

// Update Proxy Config Params
func (r UniverseUpgradesManagementAPIUpdateProxyConfigRequest) UpdateProxyConfigParams(updateProxyConfigParams ProxyConfigUpdateParams) UniverseUpgradesManagementAPIUpdateProxyConfigRequest {
	r.updateProxyConfigParams = &updateProxyConfigParams
	return r
}

func (r UniverseUpgradesManagementAPIUpdateProxyConfigRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpdateProxyConfigRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpdateProxyConfigRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpdateProxyConfigExecute(r)
}

/*
UpdateProxyConfig Update Proxy Config

WARNING: This is a preview API that could change. Queues a task to perform Proxy config update in the Universe details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpdateProxyConfigRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpdateProxyConfig(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpdateProxyConfigRequest {
	return UniverseUpgradesManagementAPIUpdateProxyConfigRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpdateProxyConfigExecute(r UniverseUpgradesManagementAPIUpdateProxyConfigRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpdateProxyConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/proxy_config"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateProxyConfigParams == nil {
		return localVarReturnValue, nil, reportError("updateProxyConfigParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateProxyConfigParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeCertsRequest struct {
	ctx               context.Context
	ApiService        *UniverseUpgradesManagementAPIService
	cUUID             string
	uniUUID           string
	certsRotateParams *CertsRotateParams
	request           *interface{}
}

// Certs Rotate Params
func (r UniverseUpgradesManagementAPIUpgradeCertsRequest) CertsRotateParams(certsRotateParams CertsRotateParams) UniverseUpgradesManagementAPIUpgradeCertsRequest {
	r.certsRotateParams = &certsRotateParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeCertsRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeCertsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeCertsRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeCertsExecute(r)
}

/*
UpgradeCerts Upgrade Certs

Queues a task to perform certificate rotation and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeCertsRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeCerts(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeCertsRequest {
	return UniverseUpgradesManagementAPIUpgradeCertsRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeCertsExecute(r UniverseUpgradesManagementAPIUpgradeCertsRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeCerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/certs"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certsRotateParams == nil {
		return localVarReturnValue, nil, reportError("certsRotateParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.certsRotateParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeDBVersionRequest struct {
	ctx                   context.Context
	ApiService            *UniverseUpgradesManagementAPIService
	cUUID                 string
	uniUUID               string
	softwareUpgradeParams *SoftwareUpgradeParams
	request               *interface{}
}

// Software Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeDBVersionRequest) SoftwareUpgradeParams(softwareUpgradeParams SoftwareUpgradeParams) UniverseUpgradesManagementAPIUpgradeDBVersionRequest {
	r.softwareUpgradeParams = &softwareUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeDBVersionRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeDBVersionRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeDBVersionRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeDBVersionExecute(r)
}

/*
UpgradeDBVersion Upgrade DB version

WARNING: This is a preview API that could change. This is a two step DB software version upgrade, Upgrade DB version and then finalize software which would be same as of upgrade software but additionally support rollback before upgrade finalize.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeDBVersionRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeDBVersion(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeDBVersionRequest {
	return UniverseUpgradesManagementAPIUpgradeDBVersionRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeDBVersionExecute(r UniverseUpgradesManagementAPIUpgradeDBVersionRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeDBVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/db_version"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeGFlagsRequest struct {
	ctx                 context.Context
	ApiService          *UniverseUpgradesManagementAPIService
	cUUID               string
	uniUUID             string
	gflagsUpgradeParams *GFlagsUpgradeParams
	request             *interface{}
}

// GFlags Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeGFlagsRequest) GflagsUpgradeParams(gflagsUpgradeParams GFlagsUpgradeParams) UniverseUpgradesManagementAPIUpgradeGFlagsRequest {
	r.gflagsUpgradeParams = &gflagsUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeGFlagsRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeGFlagsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeGFlagsRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeGFlagsExecute(r)
}

/*
UpgradeGFlags Upgrade GFlags

Queues a task to perform gflags upgrade and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeGFlagsRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeGFlags(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeGFlagsRequest {
	return UniverseUpgradesManagementAPIUpgradeGFlagsRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeGFlagsExecute(r UniverseUpgradesManagementAPIUpgradeGFlagsRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeGFlags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/gflags"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gflagsUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("gflagsUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gflagsUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest struct {
	ctx                              context.Context
	ApiService                       *UniverseUpgradesManagementAPIService
	cUUID                            string
	uniUUID                          string
	kubernetesOverridesUpgradeParams *KubernetesOverridesUpgradeParams
	request                          *interface{}
}

// Kubernetes Override Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest) KubernetesOverridesUpgradeParams(kubernetesOverridesUpgradeParams KubernetesOverridesUpgradeParams) UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest {
	r.kubernetesOverridesUpgradeParams = &kubernetesOverridesUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeKubernetesOverridesExecute(r)
}

/*
UpgradeKubernetesOverrides Upgrade KubernetesOverrides

Queues a task to perform Kubernetesoverrides upgrade for a kubernetes universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeKubernetesOverrides(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest {
	return UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeKubernetesOverridesExecute(r UniverseUpgradesManagementAPIUpgradeKubernetesOverridesRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeKubernetesOverrides")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/kubernetes_overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kubernetesOverridesUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("kubernetesOverridesUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kubernetesOverridesUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeSoftwareRequest struct {
	ctx                   context.Context
	ApiService            *UniverseUpgradesManagementAPIService
	cUUID                 string
	uniUUID               string
	softwareUpgradeParams *SoftwareUpgradeParams
	request               *interface{}
}

// Software Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeSoftwareRequest) SoftwareUpgradeParams(softwareUpgradeParams SoftwareUpgradeParams) UniverseUpgradesManagementAPIUpgradeSoftwareRequest {
	r.softwareUpgradeParams = &softwareUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeSoftwareRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeSoftwareRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeSoftwareRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeSoftwareExecute(r)
}

/*
UpgradeSoftware Upgrade Software

Queues a task to perform software upgrade and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeSoftwareRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeSoftware(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeSoftwareRequest {
	return UniverseUpgradesManagementAPIUpgradeSoftwareRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeSoftwareExecute(r UniverseUpgradesManagementAPIUpgradeSoftwareRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeSoftware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("softwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeSystemdRequest struct {
	ctx                  context.Context
	ApiService           *UniverseUpgradesManagementAPIService
	cUUID                string
	uniUUID              string
	systemdUpgradeParams *SystemdUpgradeParams
	request              *interface{}
}

// Systemd Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeSystemdRequest) SystemdUpgradeParams(systemdUpgradeParams SystemdUpgradeParams) UniverseUpgradesManagementAPIUpgradeSystemdRequest {
	r.systemdUpgradeParams = &systemdUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeSystemdRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeSystemdRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeSystemdRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeSystemdExecute(r)
}

/*
UpgradeSystemd Upgrade Systemd

Queues a task to perform systemd upgrade and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeSystemdRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeSystemd(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeSystemdRequest {
	return UniverseUpgradesManagementAPIUpgradeSystemdRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeSystemdExecute(r UniverseUpgradesManagementAPIUpgradeSystemdRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeSystemd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/systemd"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.systemdUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("systemdUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.systemdUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest struct {
	ctx                             context.Context
	ApiService                      *UniverseUpgradesManagementAPIService
	cUUID                           string
	uniUUID                         string
	thirdpartySoftwareUpgradeParams *ThirdpartySoftwareUpgradeParams
	request                         *interface{}
}

// Thirdparty Software Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest) ThirdpartySoftwareUpgradeParams(thirdpartySoftwareUpgradeParams ThirdpartySoftwareUpgradeParams) UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest {
	r.thirdpartySoftwareUpgradeParams = &thirdpartySoftwareUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeThirdpartySoftwareExecute(r)
}

/*
UpgradeThirdpartySoftware Upgrade third-party software

Queues a task to perform upgrade third-party software in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeThirdpartySoftware(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest {
	return UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeThirdpartySoftwareExecute(r UniverseUpgradesManagementAPIUpgradeThirdpartySoftwareRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeThirdpartySoftware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/thirdparty_software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.thirdpartySoftwareUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("thirdpartySoftwareUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.thirdpartySoftwareUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeTlsRequest struct {
	ctx             context.Context
	ApiService      *UniverseUpgradesManagementAPIService
	cUUID           string
	uniUUID         string
	tlsToggleParams *TlsToggleParams
	request         *interface{}
}

// TLS Toggle Params
func (r UniverseUpgradesManagementAPIUpgradeTlsRequest) TlsToggleParams(tlsToggleParams TlsToggleParams) UniverseUpgradesManagementAPIUpgradeTlsRequest {
	r.tlsToggleParams = &tlsToggleParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeTlsRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeTlsRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeTlsRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeTlsExecute(r)
}

/*
UpgradeTls Upgrade TLS

Queues a task to perform TLS ugprade and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeTlsRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeTls(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeTlsRequest {
	return UniverseUpgradesManagementAPIUpgradeTlsRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeTlsExecute(r UniverseUpgradesManagementAPIUpgradeTlsRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeTls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/tls"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tlsToggleParams == nil {
		return localVarReturnValue, nil, reportError("tlsToggleParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsToggleParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseUpgradesManagementAPIUpgradeVMImageRequest struct {
	ctx                  context.Context
	ApiService           *UniverseUpgradesManagementAPIService
	cUUID                string
	uniUUID              string
	vmimageUpgradeParams *VMImageUpgradeParams
	request              *interface{}
}

// VM Image Upgrade Params
func (r UniverseUpgradesManagementAPIUpgradeVMImageRequest) VmimageUpgradeParams(vmimageUpgradeParams VMImageUpgradeParams) UniverseUpgradesManagementAPIUpgradeVMImageRequest {
	r.vmimageUpgradeParams = &vmimageUpgradeParams
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeVMImageRequest) Request(request interface{}) UniverseUpgradesManagementAPIUpgradeVMImageRequest {
	r.request = &request
	return r
}

func (r UniverseUpgradesManagementAPIUpgradeVMImageRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpgradeVMImageExecute(r)
}

/*
UpgradeVMImage Upgrade VM Image

Queues a task to perform VM Image upgrade and rolling restart in a universe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@return UniverseUpgradesManagementAPIUpgradeVMImageRequest
*/
func (a *UniverseUpgradesManagementAPIService) UpgradeVMImage(ctx context.Context, cUUID string, uniUUID string) UniverseUpgradesManagementAPIUpgradeVMImageRequest {
	return UniverseUpgradesManagementAPIUpgradeVMImageRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
	}
}

// Execute executes the request
//
//	@return YBPTask
func (a *UniverseUpgradesManagementAPIService) UpgradeVMImageExecute(r UniverseUpgradesManagementAPIUpgradeVMImageRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseUpgradesManagementAPIService.UpgradeVMImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/upgrade/vm"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmimageUpgradeParams == nil {
		return localVarReturnValue, nil, reportError("vmimageUpgradeParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vmimageUpgradeParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
