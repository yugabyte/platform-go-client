/*
YugabyteDB Anywhere APIs

ALPHA - NOT FOR EXTERNAL USE

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ScheduleManagementAPIService ScheduleManagementAPI service
type ScheduleManagementAPIService service

type ScheduleManagementAPIDeleteBackupScheduleAsyncRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	uniUUID    string
	sUUID      string
	request    *interface{}
}

func (r ScheduleManagementAPIDeleteBackupScheduleAsyncRequest) Request(request interface{}) ScheduleManagementAPIDeleteBackupScheduleAsyncRequest {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIDeleteBackupScheduleAsyncRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.DeleteBackupScheduleAsyncExecute(r)
}

/*
DeleteBackupScheduleAsync Delete a backup schedule async

WARNING: This is a preview API that could change. Delete a backup schedule async.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@param sUUID
	@return ScheduleManagementAPIDeleteBackupScheduleAsyncRequest
*/
func (a *ScheduleManagementAPIService) DeleteBackupScheduleAsync(ctx context.Context, cUUID string, uniUUID string, sUUID string) ScheduleManagementAPIDeleteBackupScheduleAsyncRequest {
	return ScheduleManagementAPIDeleteBackupScheduleAsyncRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return Schedule
func (a *ScheduleManagementAPIService) DeleteBackupScheduleAsyncExecute(r ScheduleManagementAPIDeleteBackupScheduleAsyncRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.DeleteBackupScheduleAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/schedules/{sUUID}/delete_backup_schedule_async"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIDeleteScheduleRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	sUUID      string
	request    *interface{}
}

func (r ScheduleManagementAPIDeleteScheduleRequest) Request(request interface{}) ScheduleManagementAPIDeleteScheduleRequest {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIDeleteScheduleRequest) Execute() (*YBPSuccess, *http.Response, error) {
	return r.ApiService.DeleteScheduleExecute(r)
}

/*
DeleteSchedule Delete a schedule  - deprecated

<b style="color:#ff0000">Deprecated since YBA version 2.20.0.0.</b></p>Use 'Delete a schedule V2' instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param sUUID
	@return ScheduleManagementAPIDeleteScheduleRequest

Deprecated
*/
func (a *ScheduleManagementAPIService) DeleteSchedule(ctx context.Context, cUUID string, sUUID string) ScheduleManagementAPIDeleteScheduleRequest {
	return ScheduleManagementAPIDeleteScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return YBPSuccess
//
// Deprecated
func (a *ScheduleManagementAPIService) DeleteScheduleExecute(r ScheduleManagementAPIDeleteScheduleRequest) (*YBPSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.DeleteSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules/{sUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIDeleteScheduleV2Request struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	sUUID      string
	request    *interface{}
}

func (r ScheduleManagementAPIDeleteScheduleV2Request) Request(request interface{}) ScheduleManagementAPIDeleteScheduleV2Request {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIDeleteScheduleV2Request) Execute() (*YBPSuccess, *http.Response, error) {
	return r.ApiService.DeleteScheduleV2Execute(r)
}

/*
DeleteScheduleV2 Delete a schedule V2 - deprecated

<b style="color:#ff0000">Deprecated since YBA version 2024.2.0.0.</b></p>Use 'Delete a backup schedule async' instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param sUUID
	@return ScheduleManagementAPIDeleteScheduleV2Request

Deprecated
*/
func (a *ScheduleManagementAPIService) DeleteScheduleV2(ctx context.Context, cUUID string, sUUID string) ScheduleManagementAPIDeleteScheduleV2Request {
	return ScheduleManagementAPIDeleteScheduleV2Request{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return YBPSuccess
//
// Deprecated
func (a *ScheduleManagementAPIService) DeleteScheduleV2Execute(r ScheduleManagementAPIDeleteScheduleV2Request) (*YBPSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YBPSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.DeleteScheduleV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules/{sUUID}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIEditBackupScheduleAsyncRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	uniUUID    string
	sUUID      string
	body       *BackupScheduleEditParams
	request    *interface{}
}

func (r ScheduleManagementAPIEditBackupScheduleAsyncRequest) Body(body BackupScheduleEditParams) ScheduleManagementAPIEditBackupScheduleAsyncRequest {
	r.body = &body
	return r
}

func (r ScheduleManagementAPIEditBackupScheduleAsyncRequest) Request(request interface{}) ScheduleManagementAPIEditBackupScheduleAsyncRequest {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIEditBackupScheduleAsyncRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.EditBackupScheduleAsyncExecute(r)
}

/*
EditBackupScheduleAsync Edit a backup schedule async

WARNING: This is a preview API that could change. Edit a backup schedule async.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@param sUUID
	@return ScheduleManagementAPIEditBackupScheduleAsyncRequest
*/
func (a *ScheduleManagementAPIService) EditBackupScheduleAsync(ctx context.Context, cUUID string, uniUUID string, sUUID string) ScheduleManagementAPIEditBackupScheduleAsyncRequest {
	return ScheduleManagementAPIEditBackupScheduleAsyncRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return Schedule
func (a *ScheduleManagementAPIService) EditBackupScheduleAsyncExecute(r ScheduleManagementAPIEditBackupScheduleAsyncRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.EditBackupScheduleAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/schedules/{sUUID}/edit_backup_schedule_async"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIEditBackupScheduleV2Request struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	sUUID      string
	body       *EditBackupScheduleParams
	request    *interface{}
}

func (r ScheduleManagementAPIEditBackupScheduleV2Request) Body(body EditBackupScheduleParams) ScheduleManagementAPIEditBackupScheduleV2Request {
	r.body = &body
	return r
}

func (r ScheduleManagementAPIEditBackupScheduleV2Request) Request(request interface{}) ScheduleManagementAPIEditBackupScheduleV2Request {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIEditBackupScheduleV2Request) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.EditBackupScheduleV2Execute(r)
}

/*
EditBackupScheduleV2 Edit a backup schedule V2 - deprecated

<b style="color:#ff0000">Deprecated since YBA version 2024.2.0.0.</b></p>Use 'Edit a backup schedule async' instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param sUUID
	@return ScheduleManagementAPIEditBackupScheduleV2Request

Deprecated
*/
func (a *ScheduleManagementAPIService) EditBackupScheduleV2(ctx context.Context, cUUID string, sUUID string) ScheduleManagementAPIEditBackupScheduleV2Request {
	return ScheduleManagementAPIEditBackupScheduleV2Request{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return Schedule
//
// Deprecated
func (a *ScheduleManagementAPIService) EditBackupScheduleV2Execute(r ScheduleManagementAPIEditBackupScheduleV2Request) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.EditBackupScheduleV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules/{sUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIGetScheduleRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	sUUID      string
}

func (r ScheduleManagementAPIGetScheduleRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.GetScheduleExecute(r)
}

/*
GetSchedule Get Schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param sUUID
	@return ScheduleManagementAPIGetScheduleRequest
*/
func (a *ScheduleManagementAPIService) GetSchedule(ctx context.Context, cUUID string, sUUID string) ScheduleManagementAPIGetScheduleRequest {
	return ScheduleManagementAPIGetScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return Schedule
func (a *ScheduleManagementAPIService) GetScheduleExecute(r ScheduleManagementAPIGetScheduleRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.GetSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules/{sUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIListSchedulesRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
}

func (r ScheduleManagementAPIListSchedulesRequest) Execute() ([]Schedule, *http.Response, error) {
	return r.ApiService.ListSchedulesExecute(r)
}

/*
ListSchedules List schedules - deprecated

<b style="color:#ff0000">Deprecated since YBA version 2.20.0.0.</b></p> Use 'List schedules V2' instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@return ScheduleManagementAPIListSchedulesRequest

Deprecated
*/
func (a *ScheduleManagementAPIService) ListSchedules(ctx context.Context, cUUID string) ScheduleManagementAPIListSchedulesRequest {
	return ScheduleManagementAPIListSchedulesRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
	}
}

// Execute executes the request
//
//	@return []Schedule
//
// Deprecated
func (a *ScheduleManagementAPIService) ListSchedulesExecute(r ScheduleManagementAPIListSchedulesRequest) ([]Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.ListSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIListSchedulesV2Request struct {
	ctx                 context.Context
	ApiService          *ScheduleManagementAPIService
	cUUID               string
	pageScheduleRequest *SchedulePagedApiQuery
	request             *interface{}
}

func (r ScheduleManagementAPIListSchedulesV2Request) PageScheduleRequest(pageScheduleRequest SchedulePagedApiQuery) ScheduleManagementAPIListSchedulesV2Request {
	r.pageScheduleRequest = &pageScheduleRequest
	return r
}

func (r ScheduleManagementAPIListSchedulesV2Request) Request(request interface{}) ScheduleManagementAPIListSchedulesV2Request {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIListSchedulesV2Request) Execute() (*SchedulePagedResponse, *http.Response, error) {
	return r.ApiService.ListSchedulesV2Execute(r)
}

/*
ListSchedulesV2 List schedules V2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@return ScheduleManagementAPIListSchedulesV2Request
*/
func (a *ScheduleManagementAPIService) ListSchedulesV2(ctx context.Context, cUUID string) ScheduleManagementAPIListSchedulesV2Request {
	return ScheduleManagementAPIListSchedulesV2Request{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
	}
}

// Execute executes the request
//
//	@return SchedulePagedResponse
func (a *ScheduleManagementAPIService) ListSchedulesV2Execute(r ScheduleManagementAPIListSchedulesV2Request) (*SchedulePagedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SchedulePagedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.ListSchedulesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/schedules/page"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pageScheduleRequest == nil {
		return localVarReturnValue, nil, reportError("pageScheduleRequest is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pageScheduleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScheduleManagementAPIToggleBackupScheduleRequest struct {
	ctx        context.Context
	ApiService *ScheduleManagementAPIService
	cUUID      string
	uniUUID    string
	sUUID      string
	body       *BackupScheduleToggleParams
	request    *interface{}
}

func (r ScheduleManagementAPIToggleBackupScheduleRequest) Body(body BackupScheduleToggleParams) ScheduleManagementAPIToggleBackupScheduleRequest {
	r.body = &body
	return r
}

func (r ScheduleManagementAPIToggleBackupScheduleRequest) Request(request interface{}) ScheduleManagementAPIToggleBackupScheduleRequest {
	r.request = &request
	return r
}

func (r ScheduleManagementAPIToggleBackupScheduleRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.ToggleBackupScheduleExecute(r)
}

/*
ToggleBackupSchedule Toggle a backup schedule

WARNING: This is a preview API that could change. Toggle a backup schedule. Only allowed to toggle backup schedule state between Active and Stopped.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cUUID
	@param uniUUID
	@param sUUID
	@return ScheduleManagementAPIToggleBackupScheduleRequest
*/
func (a *ScheduleManagementAPIService) ToggleBackupSchedule(ctx context.Context, cUUID string, uniUUID string, sUUID string) ScheduleManagementAPIToggleBackupScheduleRequest {
	return ScheduleManagementAPIToggleBackupScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		cUUID:      cUUID,
		uniUUID:    uniUUID,
		sUUID:      sUUID,
	}
}

// Execute executes the request
//
//	@return Schedule
func (a *ScheduleManagementAPIService) ToggleBackupScheduleExecute(r ScheduleManagementAPIToggleBackupScheduleRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleManagementAPIService.ToggleBackupSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/schedules/{sUUID}/pause_resume"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sUUID"+"}", url.PathEscape(parameterValueToString(r.sUUID, "sUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
