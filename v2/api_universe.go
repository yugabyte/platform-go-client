/*
YugabyteDB Anywhere V2 APIs

An improved set of APIs for managing YugabyteDB Anywhere

API version: v2
Contact: support@yugabyte.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UniverseAPIService UniverseAPI service
type UniverseAPIService service

type UniverseAPIAddClusterRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	clusterAddSpec *ClusterAddSpec
}

func (r UniverseAPIAddClusterRequest) ClusterAddSpec(clusterAddSpec ClusterAddSpec) UniverseAPIAddClusterRequest {
	r.clusterAddSpec = &clusterAddSpec
	return r
}

func (r UniverseAPIAddClusterRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.AddClusterExecute(r)
}

/*
AddCluster Add a cluster to a YugabyteDB Universe

Add a cluster (eg. read replica cluster) to a YugabyteDB universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIAddClusterRequest
*/
func (a *UniverseAPIService) AddCluster(ctx context.Context, cUUID string, uniUUID string) UniverseAPIAddClusterRequest {
	return UniverseAPIAddClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) AddClusterExecute(r UniverseAPIAddClusterRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.AddCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/clusters"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterAddSpec == nil {
		return localVarReturnValue, nil, reportError("clusterAddSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterAddSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIAttachUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	attachUniverseSpec *AttachUniverseSpec
}

func (r UniverseAPIAttachUniverseRequest) AttachUniverseSpec(attachUniverseSpec AttachUniverseSpec) UniverseAPIAttachUniverseRequest {
	r.attachUniverseSpec = &attachUniverseSpec
	return r
}

func (r UniverseAPIAttachUniverseRequest) Execute() (*http.Response, error) {
	return r.ApiService.AttachUniverseExecute(r)
}

/*
AttachUniverse Attach universe

Import universe metadata to (destination) YBA using a given tgz file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIAttachUniverseRequest
*/
func (a *UniverseAPIService) AttachUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIAttachUniverseRequest {
	return UniverseAPIAttachUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
func (a *UniverseAPIService) AttachUniverseExecute(r UniverseAPIAttachUniverseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.AttachUniverse")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/attach"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachUniverseSpec == nil {
		return nil, reportError("attachUniverseSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachUniverseSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UniverseAPIConfigureMetricsExportRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	configureMetricsExportSpec *ConfigureMetricsExportSpec
}

// ConfigureMetricsExportReq  Payload to configure metrics export. Part of ConfigureMetricsExportReq 
func (r UniverseAPIConfigureMetricsExportRequest) ConfigureMetricsExportSpec(configureMetricsExportSpec ConfigureMetricsExportSpec) UniverseAPIConfigureMetricsExportRequest {
	r.configureMetricsExportSpec = &configureMetricsExportSpec
	return r
}

func (r UniverseAPIConfigureMetricsExportRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.ConfigureMetricsExportExecute(r)
}

/*
ConfigureMetricsExport Configure metrics export

Configure metrics export from a universe to a metrics export telemetry provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIConfigureMetricsExportRequest
*/
func (a *UniverseAPIService) ConfigureMetricsExport(ctx context.Context, cUUID string, uniUUID string) UniverseAPIConfigureMetricsExportRequest {
	return UniverseAPIConfigureMetricsExportRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) ConfigureMetricsExportExecute(r UniverseAPIConfigureMetricsExportRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.ConfigureMetricsExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/metrics-export-config"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configureMetricsExportSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIConfigureQueryLoggingRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeQueryLogsExport *UniverseQueryLogsExport
}

// UniverseQueryLogsExportReq  Payload to configure export of query logs. Part of UniverseQueryLogsExportReq 
func (r UniverseAPIConfigureQueryLoggingRequest) UniverseQueryLogsExport(universeQueryLogsExport UniverseQueryLogsExport) UniverseAPIConfigureQueryLoggingRequest {
	r.universeQueryLogsExport = &universeQueryLogsExport
	return r
}

func (r UniverseAPIConfigureQueryLoggingRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.ConfigureQueryLoggingExecute(r)
}

/*
ConfigureQueryLogging Configure Query Log for YugabyteDB Universe

Configure Query Log for a YugabyteDB Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIConfigureQueryLoggingRequest
*/
func (a *UniverseAPIService) ConfigureQueryLogging(ctx context.Context, cUUID string, uniUUID string) UniverseAPIConfigureQueryLoggingRequest {
	return UniverseAPIConfigureQueryLoggingRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) ConfigureQueryLoggingExecute(r UniverseAPIConfigureQueryLoggingRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.ConfigureQueryLogging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/query-log-config"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeQueryLogsExport
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPICreateUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	universeCreateSpec *UniverseCreateSpec
}

func (r UniverseAPICreateUniverseRequest) UniverseCreateSpec(universeCreateSpec UniverseCreateSpec) UniverseAPICreateUniverseRequest {
	r.universeCreateSpec = &universeCreateSpec
	return r
}

func (r UniverseAPICreateUniverseRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.CreateUniverseExecute(r)
}

/*
CreateUniverse Create a YugabyteDB Universe

Create all the clusters of a YugabyteDB universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @return UniverseAPICreateUniverseRequest
*/
func (a *UniverseAPIService) CreateUniverse(ctx context.Context, cUUID string) UniverseAPICreateUniverseRequest {
	return UniverseAPICreateUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) CreateUniverseExecute(r UniverseAPICreateUniverseRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.CreateUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeCreateSpec == nil {
		return localVarReturnValue, nil, reportError("universeCreateSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeCreateSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIDeleteAttachDetachMetadataRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
}

func (r UniverseAPIDeleteAttachDetachMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAttachDetachMetadataExecute(r)
}

/*
DeleteAttachDetachMetadata Delete attach/detach metadata

Delete metadata of a universe from (source) YBA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIDeleteAttachDetachMetadataRequest
*/
func (a *UniverseAPIService) DeleteAttachDetachMetadata(ctx context.Context, cUUID string, uniUUID string) UniverseAPIDeleteAttachDetachMetadataRequest {
	return UniverseAPIDeleteAttachDetachMetadataRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
func (a *UniverseAPIService) DeleteAttachDetachMetadataExecute(r UniverseAPIDeleteAttachDetachMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.DeleteAttachDetachMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/attach-detach-metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UniverseAPIDeleteClusterRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	clsUUID string
	isForceDelete *bool
}

// Whether to force delete the cluster
func (r UniverseAPIDeleteClusterRequest) IsForceDelete(isForceDelete bool) UniverseAPIDeleteClusterRequest {
	r.isForceDelete = &isForceDelete
	return r
}

func (r UniverseAPIDeleteClusterRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.DeleteClusterExecute(r)
}

/*
DeleteCluster Delete an additional cluster(s) of a YugabyteDB Universe

Delete an additional cluster (eg. read replica cluster) of a YugabyteDB universe. Primary cluster is deleted along with Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @param clsUUID Cluster UUID
 @return UniverseAPIDeleteClusterRequest
*/
func (a *UniverseAPIService) DeleteCluster(ctx context.Context, cUUID string, uniUUID string, clsUUID string) UniverseAPIDeleteClusterRequest {
	return UniverseAPIDeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
		clsUUID: clsUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) DeleteClusterExecute(r UniverseAPIDeleteClusterRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/clusters/{clsUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clsUUID"+"}", url.PathEscape(parameterValueToString(r.clsUUID, "clsUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isForceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", r.isForceDelete, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", defaultValue, "form", "")
        r.isForceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIDeleteUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeDeleteSpec *UniverseDeleteSpec
}

func (r UniverseAPIDeleteUniverseRequest) UniverseDeleteSpec(universeDeleteSpec UniverseDeleteSpec) UniverseAPIDeleteUniverseRequest {
	r.universeDeleteSpec = &universeDeleteSpec
	return r
}

func (r UniverseAPIDeleteUniverseRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.DeleteUniverseExecute(r)
}

/*
DeleteUniverse Delete a universe

Delete Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIDeleteUniverseRequest
*/
func (a *UniverseAPIService) DeleteUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIDeleteUniverseRequest {
	return UniverseAPIDeleteUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) DeleteUniverseExecute(r UniverseAPIDeleteUniverseRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.DeleteUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeDeleteSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIDetachUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	detachUniverseSpec *DetachUniverseSpec
}

func (r UniverseAPIDetachUniverseRequest) DetachUniverseSpec(detachUniverseSpec DetachUniverseSpec) UniverseAPIDetachUniverseRequest {
	r.detachUniverseSpec = &detachUniverseSpec
	return r
}

func (r UniverseAPIDetachUniverseRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DetachUniverseExecute(r)
}

/*
DetachUniverse Detach universe

Export universe metadata to a tgz file from (source) YBA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIDetachUniverseRequest
*/
func (a *UniverseAPIService) DetachUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIDetachUniverseRequest {
	return UniverseAPIDetachUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *UniverseAPIService) DetachUniverseExecute(r UniverseAPIDetachUniverseRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.DetachUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/detach"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.detachUniverseSpec == nil {
		return localVarReturnValue, nil, reportError("detachUniverseSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/gzip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.detachUniverseSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIEditGFlagsRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeEditGFlags *UniverseEditGFlags
}

func (r UniverseAPIEditGFlagsRequest) UniverseEditGFlags(universeEditGFlags UniverseEditGFlags) UniverseAPIEditGFlagsRequest {
	r.universeEditGFlags = &universeEditGFlags
	return r
}

func (r UniverseAPIEditGFlagsRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.EditGFlagsExecute(r)
}

/*
EditGFlags Edit GFlags

Queues a task to edit GFlags of a universe. The input set of GFlags will replace any existing GFlags in the universe. Refer [YB-Master configuration flags](https://docs.yugabyte.com/preview/reference/configuration/yb-master/#configuration-flags) and [YB-TServer configuration flags](https://docs.yugabyte.com/preview/reference/configuration/yb-tserver/#configuration-flags).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIEditGFlagsRequest
*/
func (a *UniverseAPIService) EditGFlags(ctx context.Context, cUUID string, uniUUID string) UniverseAPIEditGFlagsRequest {
	return UniverseAPIEditGFlagsRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) EditGFlagsExecute(r UniverseAPIEditGFlagsRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.EditGFlags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/gflags"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeEditGFlags == nil {
		return localVarReturnValue, nil, reportError("universeEditGFlags is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeEditGFlags
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIEditKubernetesOverridesRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeEditKubernetesOverrides *UniverseEditKubernetesOverrides
}

func (r UniverseAPIEditKubernetesOverridesRequest) UniverseEditKubernetesOverrides(universeEditKubernetesOverrides UniverseEditKubernetesOverrides) UniverseAPIEditKubernetesOverridesRequest {
	r.universeEditKubernetesOverrides = &universeEditKubernetesOverrides
	return r
}

func (r UniverseAPIEditKubernetesOverridesRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.EditKubernetesOverridesExecute(r)
}

/*
EditKubernetesOverrides Edit Kubernetes Helm Overrides

Update the kubernetes helm override values. This can be used to add custom settings to
kubernetes resources managed by YugabyteDB Anywhere. These override values can apply globally
to a universe or per AZ.

See https://github.com/yugabyte/charts/blob/master/stable/yugabyte/values.yaml for possible
override options.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIEditKubernetesOverridesRequest
*/
func (a *UniverseAPIService) EditKubernetesOverrides(ctx context.Context, cUUID string, uniUUID string) UniverseAPIEditKubernetesOverridesRequest {
	return UniverseAPIEditKubernetesOverridesRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) EditKubernetesOverridesExecute(r UniverseAPIEditKubernetesOverridesRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.EditKubernetesOverrides")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/kubernetes-overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeEditKubernetesOverrides == nil {
		return localVarReturnValue, nil, reportError("universeEditKubernetesOverrides is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeEditKubernetesOverrides
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIEditUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeEditSpec *UniverseEditSpec
}

func (r UniverseAPIEditUniverseRequest) UniverseEditSpec(universeEditSpec UniverseEditSpec) UniverseAPIEditUniverseRequest {
	r.universeEditSpec = &universeEditSpec
	return r
}

func (r UniverseAPIEditUniverseRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.EditUniverseExecute(r)
}

/*
EditUniverse Edit a YugabyteDB Universe

Edit the clusters of a single YugabyteDB Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIEditUniverseRequest
*/
func (a *UniverseAPIService) EditUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIEditUniverseRequest {
	return UniverseAPIEditUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) EditUniverseExecute(r UniverseAPIEditUniverseRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.EditUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeEditSpec == nil {
		return localVarReturnValue, nil, reportError("universeEditSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeEditSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIEncryptionInTransitCertRotateRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeCertRotateSpec *UniverseCertRotateSpec
}

func (r UniverseAPIEncryptionInTransitCertRotateRequest) UniverseCertRotateSpec(universeCertRotateSpec UniverseCertRotateSpec) UniverseAPIEncryptionInTransitCertRotateRequest {
	r.universeCertRotateSpec = &universeCertRotateSpec
	return r
}

func (r UniverseAPIEncryptionInTransitCertRotateRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.EncryptionInTransitCertRotateExecute(r)
}

/*
EncryptionInTransitCertRotate Rotate TLS Certs

Rotate the certs used for encryption in transit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIEncryptionInTransitCertRotateRequest
*/
func (a *UniverseAPIService) EncryptionInTransitCertRotate(ctx context.Context, cUUID string, uniUUID string) UniverseAPIEncryptionInTransitCertRotateRequest {
	return UniverseAPIEncryptionInTransitCertRotateRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) EncryptionInTransitCertRotateExecute(r UniverseAPIEncryptionInTransitCertRotateRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.EncryptionInTransitCertRotate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/encryption/in-transit/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeCertRotateSpec == nil {
		return localVarReturnValue, nil, reportError("universeCertRotateSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeCertRotateSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIEncryptionInTransitToggleRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeEditEncryptionInTransit *UniverseEditEncryptionInTransit
}

func (r UniverseAPIEncryptionInTransitToggleRequest) UniverseEditEncryptionInTransit(universeEditEncryptionInTransit UniverseEditEncryptionInTransit) UniverseAPIEncryptionInTransitToggleRequest {
	r.universeEditEncryptionInTransit = &universeEditEncryptionInTransit
	return r
}

func (r UniverseAPIEncryptionInTransitToggleRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.EncryptionInTransitToggleExecute(r)
}

/*
EncryptionInTransitToggle Enable or disable encryption in transit

Enable or disable encryption in transit. Encryption in transit can be both node to node or
node to client.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIEncryptionInTransitToggleRequest
*/
func (a *UniverseAPIService) EncryptionInTransitToggle(ctx context.Context, cUUID string, uniUUID string) UniverseAPIEncryptionInTransitToggleRequest {
	return UniverseAPIEncryptionInTransitToggleRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) EncryptionInTransitToggleExecute(r UniverseAPIEncryptionInTransitToggleRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.EncryptionInTransitToggle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/encryption/in-transit"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeEditEncryptionInTransit == nil {
		return localVarReturnValue, nil, reportError("universeEditEncryptionInTransit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeEditEncryptionInTransit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIFinalizeSoftwareUpgradeRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeSoftwareUpgradeFinalize *UniverseSoftwareUpgradeFinalize
}

func (r UniverseAPIFinalizeSoftwareUpgradeRequest) UniverseSoftwareUpgradeFinalize(universeSoftwareUpgradeFinalize UniverseSoftwareUpgradeFinalize) UniverseAPIFinalizeSoftwareUpgradeRequest {
	r.universeSoftwareUpgradeFinalize = &universeSoftwareUpgradeFinalize
	return r
}

func (r UniverseAPIFinalizeSoftwareUpgradeRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.FinalizeSoftwareUpgradeExecute(r)
}

/*
FinalizeSoftwareUpgrade Finalize the Upgrade YugabyteDB

Queues a task to perform finalize of a YugabyteDB Software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIFinalizeSoftwareUpgradeRequest
*/
func (a *UniverseAPIService) FinalizeSoftwareUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseAPIFinalizeSoftwareUpgradeRequest {
	return UniverseAPIFinalizeSoftwareUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) FinalizeSoftwareUpgradeExecute(r UniverseAPIFinalizeSoftwareUpgradeRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.FinalizeSoftwareUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/software/finalize"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeSoftwareUpgradeFinalize
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
}

func (r UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest) Execute() (*UniverseSoftwareUpgradeFinalizeInfo, *http.Response, error) {
	return r.ApiService.GetFinalizeSoftwareUpgradeInfoExecute(r)
}

/*
GetFinalizeSoftwareUpgradeInfo Get finalize information on the YugabyteDB upgrade

Get finalize info of a YugabyteDB Software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest
*/
func (a *UniverseAPIService) GetFinalizeSoftwareUpgradeInfo(ctx context.Context, cUUID string, uniUUID string) UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest {
	return UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return UniverseSoftwareUpgradeFinalizeInfo
func (a *UniverseAPIService) GetFinalizeSoftwareUpgradeInfoExecute(r UniverseAPIGetFinalizeSoftwareUpgradeInfoRequest) (*UniverseSoftwareUpgradeFinalizeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseSoftwareUpgradeFinalizeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetFinalizeSoftwareUpgradeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/software/finalize"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIGetUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
}

func (r UniverseAPIGetUniverseRequest) Execute() (*Universe, *http.Response, error) {
	return r.ApiService.GetUniverseExecute(r)
}

/*
GetUniverse Get a YugabyteDB Universe

Get details of a single YugabyteDB Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIGetUniverseRequest
*/
func (a *UniverseAPIService) GetUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIGetUniverseRequest {
	return UniverseAPIGetUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return Universe
func (a *UniverseAPIService) GetUniverseExecute(r UniverseAPIGetUniverseRequest) (*Universe, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Universe
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIGetUniverseResourcesRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	universeCreateSpec *UniverseCreateSpec
}

func (r UniverseAPIGetUniverseResourcesRequest) UniverseCreateSpec(universeCreateSpec UniverseCreateSpec) UniverseAPIGetUniverseResourcesRequest {
	r.universeCreateSpec = &universeCreateSpec
	return r
}

func (r UniverseAPIGetUniverseResourcesRequest) Execute() (*UniverseResourceDetails, *http.Response, error) {
	return r.ApiService.GetUniverseResourcesExecute(r)
}

/*
GetUniverseResources Get resource utilisation of a YugabyteDB Universe

Fetches an estimate of pricing and cpu/memory/storage resource utilisation for the Universe. This is meant to be used before creating the Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @return UniverseAPIGetUniverseResourcesRequest
*/
func (a *UniverseAPIService) GetUniverseResources(ctx context.Context, cUUID string) UniverseAPIGetUniverseResourcesRequest {
	return UniverseAPIGetUniverseResourcesRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return UniverseResourceDetails
func (a *UniverseAPIService) GetUniverseResourcesExecute(r UniverseAPIGetUniverseResourcesRequest) (*UniverseResourceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseResourceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/fetch-universe-resources"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeCreateSpec == nil {
		return localVarReturnValue, nil, reportError("universeCreateSpec is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeCreateSpec
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIOperatorImportUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeOperatorImportReq *UniverseOperatorImportReq
}

func (r UniverseAPIOperatorImportUniverseRequest) UniverseOperatorImportReq(universeOperatorImportReq UniverseOperatorImportReq) UniverseAPIOperatorImportUniverseRequest {
	r.universeOperatorImportReq = &universeOperatorImportReq
	return r
}

func (r UniverseAPIOperatorImportUniverseRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.OperatorImportUniverseExecute(r)
}

/*
OperatorImportUniverse Import universe to operator

Import universe to operator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIOperatorImportUniverseRequest
*/
func (a *UniverseAPIService) OperatorImportUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIOperatorImportUniverseRequest {
	return UniverseAPIOperatorImportUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) OperatorImportUniverseExecute(r UniverseAPIOperatorImportUniverseRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.OperatorImportUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/operator-import"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeOperatorImportReq == nil {
		return localVarReturnValue, nil, reportError("universeOperatorImportReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeOperatorImportReq
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIOperatorImportUniversePrecheckRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeOperatorImportReq *UniverseOperatorImportReq
}

func (r UniverseAPIOperatorImportUniversePrecheckRequest) UniverseOperatorImportReq(universeOperatorImportReq UniverseOperatorImportReq) UniverseAPIOperatorImportUniversePrecheckRequest {
	r.universeOperatorImportReq = &universeOperatorImportReq
	return r
}

func (r UniverseAPIOperatorImportUniversePrecheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.OperatorImportUniversePrecheckExecute(r)
}

/*
OperatorImportUniversePrecheck Precheck universe import to operator

Run precheck to ensure the universe can be imported to the operator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIOperatorImportUniversePrecheckRequest
*/
func (a *UniverseAPIService) OperatorImportUniversePrecheck(ctx context.Context, cUUID string, uniUUID string) UniverseAPIOperatorImportUniversePrecheckRequest {
	return UniverseAPIOperatorImportUniversePrecheckRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
func (a *UniverseAPIService) OperatorImportUniversePrecheckExecute(r UniverseAPIOperatorImportUniversePrecheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.OperatorImportUniversePrecheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/operator-import/precheck"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeOperatorImportReq == nil {
		return nil, reportError("universeOperatorImportReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeOperatorImportReq
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UniverseAPIPrecheckSoftwareUpgradeRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeSoftwareUpgradePrecheckReq *UniverseSoftwareUpgradePrecheckReq
}

func (r UniverseAPIPrecheckSoftwareUpgradeRequest) UniverseSoftwareUpgradePrecheckReq(universeSoftwareUpgradePrecheckReq UniverseSoftwareUpgradePrecheckReq) UniverseAPIPrecheckSoftwareUpgradeRequest {
	r.universeSoftwareUpgradePrecheckReq = &universeSoftwareUpgradePrecheckReq
	return r
}

func (r UniverseAPIPrecheckSoftwareUpgradeRequest) Execute() (*UniverseSoftwareUpgradePrecheckResp, *http.Response, error) {
	return r.ApiService.PrecheckSoftwareUpgradeExecute(r)
}

/*
PrecheckSoftwareUpgrade Precheck YugabyteDB version upgrade

Queues a task to perform a precheck for a YugabyteDB Software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIPrecheckSoftwareUpgradeRequest
*/
func (a *UniverseAPIService) PrecheckSoftwareUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseAPIPrecheckSoftwareUpgradeRequest {
	return UniverseAPIPrecheckSoftwareUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return UniverseSoftwareUpgradePrecheckResp
func (a *UniverseAPIService) PrecheckSoftwareUpgradeExecute(r UniverseAPIPrecheckSoftwareUpgradeRequest) (*UniverseSoftwareUpgradePrecheckResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseSoftwareUpgradePrecheckResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.PrecheckSoftwareUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/software/precheck"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeSoftwareUpgradePrecheckReq == nil {
		return localVarReturnValue, nil, reportError("universeSoftwareUpgradePrecheckReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeSoftwareUpgradePrecheckReq
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIRestartUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeRestart *UniverseRestart
}

func (r UniverseAPIRestartUniverseRequest) UniverseRestart(universeRestart UniverseRestart) UniverseAPIRestartUniverseRequest {
	r.universeRestart = &universeRestart
	return r
}

func (r UniverseAPIRestartUniverseRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.RestartUniverseExecute(r)
}

/*
RestartUniverse Restart a YugabyteDB Universe

Restart a YugabyteDB Universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIRestartUniverseRequest
*/
func (a *UniverseAPIService) RestartUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIRestartUniverseRequest {
	return UniverseAPIRestartUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) RestartUniverseExecute(r UniverseAPIRestartUniverseRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.RestartUniverse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeRestart
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIRollbackDetachUniverseRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	isForceRollback *bool
}

// Force rollback without checking current owner or detached state.
func (r UniverseAPIRollbackDetachUniverseRequest) IsForceRollback(isForceRollback bool) UniverseAPIRollbackDetachUniverseRequest {
	r.isForceRollback = &isForceRollback
	return r
}

func (r UniverseAPIRollbackDetachUniverseRequest) Execute() (*http.Response, error) {
	return r.ApiService.RollbackDetachUniverseExecute(r)
}

/*
RollbackDetachUniverse Rollback detach universe

Invoke this from the YBA that should reclaim ownership of a universe that is currently in a detached
state (ie. if this API has been invoked on the universe POST /customers/{cUUID}/universes/{uniUUID}/detach, 
on that YBA instance). A Universe can be managed only by a single instance of YBA at any time. So, 
for cases where the universe was attached to another YBA 
(ie. using POST /customers/{cUUID}/universes/{uniUUID}/attach), only isForceRollback=true 
can be used to rollback the detach operation in such case.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIRollbackDetachUniverseRequest
*/
func (a *UniverseAPIService) RollbackDetachUniverse(ctx context.Context, cUUID string, uniUUID string) UniverseAPIRollbackDetachUniverseRequest {
	return UniverseAPIRollbackDetachUniverseRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
func (a *UniverseAPIService) RollbackDetachUniverseExecute(r UniverseAPIRollbackDetachUniverseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.RollbackDetachUniverse")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/detach"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isForceRollback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceRollback", r.isForceRollback, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "isForceRollback", defaultValue, "form", "")
        r.isForceRollback = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UniverseAPIRollbackSoftwareUpgradeRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeRollbackUpgradeReq *UniverseRollbackUpgradeReq
}

func (r UniverseAPIRollbackSoftwareUpgradeRequest) UniverseRollbackUpgradeReq(universeRollbackUpgradeReq UniverseRollbackUpgradeReq) UniverseAPIRollbackSoftwareUpgradeRequest {
	r.universeRollbackUpgradeReq = &universeRollbackUpgradeReq
	return r
}

func (r UniverseAPIRollbackSoftwareUpgradeRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.RollbackSoftwareUpgradeExecute(r)
}

/*
RollbackSoftwareUpgrade Rollback YugabyteDB version

Queues a task to rollback a YugabyteDB Software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIRollbackSoftwareUpgradeRequest
*/
func (a *UniverseAPIService) RollbackSoftwareUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseAPIRollbackSoftwareUpgradeRequest {
	return UniverseAPIRollbackSoftwareUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) RollbackSoftwareUpgradeExecute(r UniverseAPIRollbackSoftwareUpgradeRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.RollbackSoftwareUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/software/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeRollbackUpgradeReq
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIStartSoftwareUpgradeRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeSoftwareUpgradeStart *UniverseSoftwareUpgradeStart
}

func (r UniverseAPIStartSoftwareUpgradeRequest) UniverseSoftwareUpgradeStart(universeSoftwareUpgradeStart UniverseSoftwareUpgradeStart) UniverseAPIStartSoftwareUpgradeRequest {
	r.universeSoftwareUpgradeStart = &universeSoftwareUpgradeStart
	return r
}

func (r UniverseAPIStartSoftwareUpgradeRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.StartSoftwareUpgradeExecute(r)
}

/*
StartSoftwareUpgrade Upgrade YugabyteDB version

Queues a task to perform a YugabyteDB Software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIStartSoftwareUpgradeRequest
*/
func (a *UniverseAPIService) StartSoftwareUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseAPIStartSoftwareUpgradeRequest {
	return UniverseAPIStartSoftwareUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) StartSoftwareUpgradeExecute(r UniverseAPIStartSoftwareUpgradeRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.StartSoftwareUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeSoftwareUpgradeStart == nil {
		return localVarReturnValue, nil, reportError("universeSoftwareUpgradeStart is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeSoftwareUpgradeStart
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPIStartThirdPartySoftwareUpgradeRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeThirdPartySoftwareUpgradeStart *UniverseThirdPartySoftwareUpgradeStart
}

func (r UniverseAPIStartThirdPartySoftwareUpgradeRequest) UniverseThirdPartySoftwareUpgradeStart(universeThirdPartySoftwareUpgradeStart UniverseThirdPartySoftwareUpgradeStart) UniverseAPIStartThirdPartySoftwareUpgradeRequest {
	r.universeThirdPartySoftwareUpgradeStart = &universeThirdPartySoftwareUpgradeStart
	return r
}

func (r UniverseAPIStartThirdPartySoftwareUpgradeRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.StartThirdPartySoftwareUpgradeExecute(r)
}

/*
StartThirdPartySoftwareUpgrade Upgrade third party software

Queues a task to perform a third party software upgrade.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPIStartThirdPartySoftwareUpgradeRequest
*/
func (a *UniverseAPIService) StartThirdPartySoftwareUpgrade(ctx context.Context, cUUID string, uniUUID string) UniverseAPIStartThirdPartySoftwareUpgradeRequest {
	return UniverseAPIStartThirdPartySoftwareUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) StartThirdPartySoftwareUpgradeExecute(r UniverseAPIStartThirdPartySoftwareUpgradeRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.StartThirdPartySoftwareUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/upgrade/third-party-software"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeThirdPartySoftwareUpgradeStart
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseAPISystemdEnableRequest struct {
	ctx context.Context
	ApiService *UniverseAPIService
	cUUID string
	uniUUID string
	universeSystemdEnableStart *UniverseSystemdEnableStart
}

func (r UniverseAPISystemdEnableRequest) UniverseSystemdEnableStart(universeSystemdEnableStart UniverseSystemdEnableStart) UniverseAPISystemdEnableRequest {
	r.universeSystemdEnableStart = &universeSystemdEnableStart
	return r
}

func (r UniverseAPISystemdEnableRequest) Execute() (*YBATask, *http.Response, error) {
	return r.ApiService.SystemdEnableExecute(r)
}

/*
SystemdEnable Migrate to Systemd controlled services

Use Systemd to control YugabyteDB services for this universe. This is a 1 way migration from
cron-based service management to systemd, and will involve a rolling restart of the universe.

This is not supported for on prem manual provisioned universes or kubernetes universes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID Customer UUID
 @param uniUUID Universe UUID
 @return UniverseAPISystemdEnableRequest
*/
func (a *UniverseAPIService) SystemdEnable(ctx context.Context, cUUID string, uniUUID string) UniverseAPISystemdEnableRequest {
	return UniverseAPISystemdEnableRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBATask
func (a *UniverseAPIService) SystemdEnableExecute(r UniverseAPISystemdEnableRequest) (*YBATask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBATask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.SystemdEnable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customers/{cUUID}/universes/{uniUUID}/systemd"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeSystemdEnableStart
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
