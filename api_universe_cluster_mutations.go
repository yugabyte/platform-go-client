/*
YugabyteDB Anywhere APIs

ALPHA - NOT FOR EXTERNAL USE

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ywclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UniverseClusterMutationsAPIService UniverseClusterMutationsAPI service
type UniverseClusterMutationsAPIService service

type UniverseClusterMutationsAPICreateAllClustersRequest struct {
	ctx context.Context
	ApiService *UniverseClusterMutationsAPIService
	cUUID string
	universeConfigureTaskParams *UniverseConfigureTaskParams
	request *interface{}
}

func (r UniverseClusterMutationsAPICreateAllClustersRequest) UniverseConfigureTaskParams(universeConfigureTaskParams UniverseConfigureTaskParams) UniverseClusterMutationsAPICreateAllClustersRequest {
	r.universeConfigureTaskParams = &universeConfigureTaskParams
	return r
}

func (r UniverseClusterMutationsAPICreateAllClustersRequest) Request(request interface{}) UniverseClusterMutationsAPICreateAllClustersRequest {
	r.request = &request
	return r
}

func (r UniverseClusterMutationsAPICreateAllClustersRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.CreateAllClustersExecute(r)
}

/*
CreateAllClusters Create Universe Clusters

This will configure and create universe with (optionally) multiple clusters. Just fill in the userIntent for PRIMARY and (optionally) an ASYNC cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @return UniverseClusterMutationsAPICreateAllClustersRequest
*/
func (a *UniverseClusterMutationsAPIService) CreateAllClusters(ctx context.Context, cUUID string) UniverseClusterMutationsAPICreateAllClustersRequest {
	return UniverseClusterMutationsAPICreateAllClustersRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *UniverseClusterMutationsAPIService) CreateAllClustersExecute(r UniverseClusterMutationsAPICreateAllClustersRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseClusterMutationsAPIService.CreateAllClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/clusters"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeConfigureTaskParams == nil {
		return localVarReturnValue, nil, reportError("universeConfigureTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeConfigureTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseClusterMutationsAPICreateReadOnlyClusterRequest struct {
	ctx context.Context
	ApiService *UniverseClusterMutationsAPIService
	cUUID string
	uniUUID string
	universeConfigureTaskParams *UniverseDefinitionTaskParams
	request *interface{}
}

func (r UniverseClusterMutationsAPICreateReadOnlyClusterRequest) UniverseConfigureTaskParams(universeConfigureTaskParams UniverseDefinitionTaskParams) UniverseClusterMutationsAPICreateReadOnlyClusterRequest {
	r.universeConfigureTaskParams = &universeConfigureTaskParams
	return r
}

func (r UniverseClusterMutationsAPICreateReadOnlyClusterRequest) Request(request interface{}) UniverseClusterMutationsAPICreateReadOnlyClusterRequest {
	r.request = &request
	return r
}

func (r UniverseClusterMutationsAPICreateReadOnlyClusterRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.CreateReadOnlyClusterExecute(r)
}

/*
CreateReadOnlyCluster Create ReadOnly Cluster

This will add a readonly cluster to existing universe. Just fill in the userIntent for ASYNC cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param uniUUID
 @return UniverseClusterMutationsAPICreateReadOnlyClusterRequest
*/
func (a *UniverseClusterMutationsAPIService) CreateReadOnlyCluster(ctx context.Context, cUUID string, uniUUID string) UniverseClusterMutationsAPICreateReadOnlyClusterRequest {
	return UniverseClusterMutationsAPICreateReadOnlyClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *UniverseClusterMutationsAPIService) CreateReadOnlyClusterExecute(r UniverseClusterMutationsAPICreateReadOnlyClusterRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseClusterMutationsAPIService.CreateReadOnlyCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/clusters/read_only"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeConfigureTaskParams == nil {
		return localVarReturnValue, nil, reportError("universeConfigureTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeConfigureTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseClusterMutationsAPIDeleteReadonlyClusterRequest struct {
	ctx context.Context
	ApiService *UniverseClusterMutationsAPIService
	cUUID string
	uniUUID string
	clustUUID string
	isForceDelete *bool
	request *interface{}
}

func (r UniverseClusterMutationsAPIDeleteReadonlyClusterRequest) IsForceDelete(isForceDelete bool) UniverseClusterMutationsAPIDeleteReadonlyClusterRequest {
	r.isForceDelete = &isForceDelete
	return r
}

func (r UniverseClusterMutationsAPIDeleteReadonlyClusterRequest) Request(request interface{}) UniverseClusterMutationsAPIDeleteReadonlyClusterRequest {
	r.request = &request
	return r
}

func (r UniverseClusterMutationsAPIDeleteReadonlyClusterRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.DeleteReadonlyClusterExecute(r)
}

/*
DeleteReadonlyCluster Delete Readonly Cluster

This will delete readonly cluster of existing universe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param uniUUID
 @param clustUUID
 @return UniverseClusterMutationsAPIDeleteReadonlyClusterRequest
*/
func (a *UniverseClusterMutationsAPIService) DeleteReadonlyCluster(ctx context.Context, cUUID string, uniUUID string, clustUUID string) UniverseClusterMutationsAPIDeleteReadonlyClusterRequest {
	return UniverseClusterMutationsAPIDeleteReadonlyClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
		clustUUID: clustUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *UniverseClusterMutationsAPIService) DeleteReadonlyClusterExecute(r UniverseClusterMutationsAPIDeleteReadonlyClusterRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseClusterMutationsAPIService.DeleteReadonlyCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/clusters/read_only/{clustUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clustUUID"+"}", url.PathEscape(parameterValueToString(r.clustUUID, "clustUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isForceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", r.isForceDelete, "", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "isForceDelete", defaultValue, "", "")
        r.isForceDelete = &defaultValue
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseClusterMutationsAPIUpdatePrimaryClusterRequest struct {
	ctx context.Context
	ApiService *UniverseClusterMutationsAPIService
	cUUID string
	uniUUID string
	universeConfigureTaskParams *UniverseConfigureTaskParams
	request *interface{}
}

func (r UniverseClusterMutationsAPIUpdatePrimaryClusterRequest) UniverseConfigureTaskParams(universeConfigureTaskParams UniverseConfigureTaskParams) UniverseClusterMutationsAPIUpdatePrimaryClusterRequest {
	r.universeConfigureTaskParams = &universeConfigureTaskParams
	return r
}

func (r UniverseClusterMutationsAPIUpdatePrimaryClusterRequest) Request(request interface{}) UniverseClusterMutationsAPIUpdatePrimaryClusterRequest {
	r.request = &request
	return r
}

func (r UniverseClusterMutationsAPIUpdatePrimaryClusterRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpdatePrimaryClusterExecute(r)
}

/*
UpdatePrimaryCluster Update Primary Cluster

This will update primary cluster of existing universe.Use API to GET current universe. Lookup universeDetails attribute of the universe resource returned. Update the necessary field (e.g. numNodes) Use this updated universeDetails as request body. See https://github.com/yugabyte/yugabyte-db/blob/master/managed/api-examples/python-simple/edit-universe.ipynb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param uniUUID
 @return UniverseClusterMutationsAPIUpdatePrimaryClusterRequest
*/
func (a *UniverseClusterMutationsAPIService) UpdatePrimaryCluster(ctx context.Context, cUUID string, uniUUID string) UniverseClusterMutationsAPIUpdatePrimaryClusterRequest {
	return UniverseClusterMutationsAPIUpdatePrimaryClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *UniverseClusterMutationsAPIService) UpdatePrimaryClusterExecute(r UniverseClusterMutationsAPIUpdatePrimaryClusterRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseClusterMutationsAPIService.UpdatePrimaryCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/clusters/primary"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeConfigureTaskParams == nil {
		return localVarReturnValue, nil, reportError("universeConfigureTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeConfigureTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest struct {
	ctx context.Context
	ApiService *UniverseClusterMutationsAPIService
	cUUID string
	uniUUID string
	universeConfigureTaskParams *UniverseConfigureTaskParams
	request *interface{}
}

func (r UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest) UniverseConfigureTaskParams(universeConfigureTaskParams UniverseConfigureTaskParams) UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest {
	r.universeConfigureTaskParams = &universeConfigureTaskParams
	return r
}

func (r UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest) Request(request interface{}) UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest {
	r.request = &request
	return r
}

func (r UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest) Execute() (*YBPTask, *http.Response, error) {
	return r.ApiService.UpdateReadOnlyClusterExecute(r)
}

/*
UpdateReadOnlyCluster Update Readonly Cluster

This will update readonly cluster of existing universe.Use API to GET current universe. Lookup universeDetails attribute of the universe resource returned. Update the necessary field (e.g. numNodes) Use this updated universeDetails as request body. See https://github.com/yugabyte/yugabyte-db/blob/master/managed/api-examples/python-simple/edit-universe.ipynb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cUUID
 @param uniUUID
 @return UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest
*/
func (a *UniverseClusterMutationsAPIService) UpdateReadOnlyCluster(ctx context.Context, cUUID string, uniUUID string) UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest {
	return UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest{
		ApiService: a,
		ctx: ctx,
		cUUID: cUUID,
		uniUUID: uniUUID,
	}
}

// Execute executes the request
//  @return YBPTask
func (a *UniverseClusterMutationsAPIService) UpdateReadOnlyClusterExecute(r UniverseClusterMutationsAPIUpdateReadOnlyClusterRequest) (*YBPTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YBPTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseClusterMutationsAPIService.UpdateReadOnlyCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/customers/{cUUID}/universes/{uniUUID}/clusters/read_only"
	localVarPath = strings.Replace(localVarPath, "{"+"cUUID"+"}", url.PathEscape(parameterValueToString(r.cUUID, "cUUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uniUUID"+"}", url.PathEscape(parameterValueToString(r.uniUUID, "uniUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.universeConfigureTaskParams == nil {
		return localVarReturnValue, nil, reportError("universeConfigureTaskParams is required and must be specified")
	}

	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.universeConfigureTaskParams
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-AUTH-YW-API-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
